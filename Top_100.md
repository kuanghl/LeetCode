### 1.Two Sum

Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.

You may assume that each input would have **exactly** one solution, and you may not use the *same* element twice.

#### 解析

方法1：暴力，时间复杂度O(n^2)

方法2：hash表存储每个数对应的下标，时间复杂度O(n)

#### 代码

方法1：很早之前用python写的暴力方法，看看就好

```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        
        lens = len(nums)
        i = 0
        a = 0
        b = 0
        while (i < lens):
            tmp = nums[i]
            h = tmp
            first = i + 1
            while (first < lens):
                h += nums[first]
                if (h == target):
                    a = i
                    b = first
                    result = []
                    result.append(a)
                    result.append(b)
                    return result
                first += 1
                h=tmp
            i += 1
```



方法2：hash

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> used;
        vector<int> res;
        for(int i=0;i<nums.size();i++){
            used[nums[i]]=i;
        }
        for(int i=0;i<nums.size();i++){
            int aim=target-nums[i];
            if(used.find(aim)!=used.end()&&used[aim]!=i){
                    res.push_back(i);
                    res.push_back(used[aim]);
                    return res;
                }
            }
        return res;
    }
};
```

### 2.Add Two Numbers

You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example:**

```
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* res=new ListNode(-1);
        ListNode* ret=res;
        ListNode* p1=l1;
        ListNode* p2=l2;
        int carry=0;
        while(p1!=nullptr||p2!=nullptr||carry){
            if(p1){
                carry+=p1->val;
                p1=p1->next;
            }
            if(p2){
                carry+=p2->val;
                p2=p2->next;
            }
            res->next=new ListNode(carry%10);
            carry/=10;
            res=res->next;
        }
        return ret->next;
    }
};
```

### 3.Longest Substring Without Repeating Characters

Given a string, find the length of the **longest substring** without repeating characters.

**Example 1:**

```
Input: "abcabcbb"
Output: 3 
Explanation: The answer is "abc", with the length of 3. 


```

**Example 2:**

```
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.


```

**Example 3:**

```
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3. 
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

#### 解析

用hash table存储不同的char

#### 代码

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char,int> tb;
        int maxlen=0,start=0,curlen=0;
        for(int i=0;i<s.size();i++){
            if(tb.find(s[i])!=tb.end()){
                for(int j=start;j<tb[s[i]];j++){
                    tb.erase(s[j]);
                }
                start=tb[s[i]]+1;
                curlen=i-start+1;
            }
            else{
                curlen++;
            }
            tb[s[i]]=i;
            maxlen=max(maxlen,curlen);
        }
        return maxlen;
    }
};
```

解法2：

滑动窗口+记录表。速度最快。

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.size();
        if(len<=1) return len;
        int res=1;
        int left=0;
        int right=0;
        int ch[256];
        memset(ch,0,sizeof(int)*256);
        ch[s[0]]=1;
        for(int i=1;i<len;++i)
        {
            right=i;
            
            if(ch[s[i]]==0||ch[s[i]]<=left)//记录值在窗口外不算重复
            {
                
                res=max(res,right-left+1);
            }
            else
            {
                left=ch[s[i]];
            }
            ch[s[i]]=i+1;
        }
        return res;
    }
};
```

### 4.Median of Two Sorted Arrays

There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

#### 解析

这是一道非常经典的题。这题更通用的形式是，给定两个已经排序好的数组，找到两者所有元素中第`k`大的元素。

`O(m+n)`的解法比较直观，直接merge两个数组，然后求第`k`大的元素。

不过我们仅仅需要第`k`大的元素，是不需要“排序”这么昂贵的操作的。可以用一个计数器，记录当前已经找到第`m`大的元素了。同时我们使用两个指针`pA`和`pB`，分别指向A和B数组的第一个元素，使用类似于merge sort的原理，如果数组A当前元素小，那么`pA++`，同时`m++`；如果数组B当前元素小，那么`pB++`，同时`m++`。最终当`m`等于`k`的时候，就得到了我们的答案，`O(k)`时间，`O(1)`空间。但是，当`k`很接近`m+n`的时候，这个方法还是`O(m+n)`的。

有没有更好的方案呢？我们可以考虑从`k`入手。如果我们每次都能够删除一个一定在第`k`大元素之前的元素，那么我们需要进行`k`次。但是如果每次我们都删除一半呢？由于A和B都是有序的，我们应该充分利用这里面的信息，类似于二分查找，也是充分利用了“有序”。

假设A和B的元素个数都大于`k/2`，我们将A的第`k/2`个元素（即`A[k/2-1]`）和B的第`k/2`个元素（即`B[k/2-1]`）进行比较，有以下三种情况（为了简化这里先假设`k`为偶数，所得到的结论对于`k`是奇数也是成立的）：

- `A[k/2-1] == B[k/2-1]`
- `A[k/2-1] > B[k/2-1]`
- `A[k/2-1] < B[k/2-1]`

如果`A[k/2-1] < B[k/2-1]`，意味着`A[0]`到`A[k/2-1]`的肯定在A∪B的top k元素的范围内，换句话说，`A[k/2-1]`不可能大于A∪B的第`k`大元素。留给读者证明。

因此，我们可以放心的删除A数组的这`k/2`个元素。同理，当`A[k/2-1] > B[k/2-1]`时，可以删除B数组的`k/2`个元素。

当`A[k/2-1] == B[k/2-1]`时，说明找到了第`k`大的元素，直接返回`A[k/2-1]`或`B[k/2-1]`即可。

因此，我们可以写一个递归函数。那么函数什么时候应该终止呢？

- 当A或B是空时，直接返回`B[k-1]`或`A[k-1]`；
- 当`k=1`时，返回`min(A[0], B[0])`；
- 当`A[k/2-1] == B[k/2-1]`时，返回`A[k/2-1]`或`B[k/2-1]`

#### 代码

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m=nums1.size();
        int n=nums2.size();
        int total=n+m;
        if(total&0x01)
            return findMedian(nums1.begin(),m,nums2.begin(),n,total/2+1);
        else
            return (findMedian(nums1.begin(),m,nums2.begin(),n,total/2)+findMedian(nums1.begin(),m,nums2.begin(),n,total/2+1))/2.0;
    }
    
    static int findMedian(vector<int>::const_iterator A,int m,vector<int>::const_iterator B,int n,int k)//k是长度，k-1是下标
    {
    	//保证m<=n，目的是第二个if
        if(m>n) return findMedian(B,n,A,m,k);
        if(m==0) return *(B+k-1);
        if(k==1) return min(*A,*B);
        int cuta=min(k/2,m),cutb=k-cuta;
        if(*(A+cuta-1) < *(B+cutb-1)){
            return findMedian(A+cuta,m-cuta,B,n,k-cuta);
        }
        else if(*(A+cuta-1) > *(B+cutb-1))
            return findMedian(A,m,B+cutb,n-cutb,k-cutb);
        else{
            return *(A+cuta-1);
        }
    }
};
```
### 5.Longest Palindromic Substring

Given a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.

**Example 1:**

```
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.


```

**Example 2:**

```
Input: "cbbd"
Output: "bb"
```

#### 解析

本题为最大回文子串，动态规划解法为：

复杂度`O(n^2)`。设状态为`f(i,j)`，表示区间[i,j]是否为回文串，则状态转移方程为

![动态规划方程](https://i.loli.net/2018/09/20/5ba3971846fb5.png)

其他解法（暴力解法，Manacher 算法）请见这篇文章 [最长回文子串——Manacher 算法](https://segmentfault.com/a/1190000003914228)

#### 代码

动态规划解法：

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        const int n=s.size();
        bool f[1000][1000] = {false};
        int maxlen=1,start=0;
        for(int j=0;j<n;j++){
            f[j][j]=true;
            for(int i=0;i<j;i++){
                f[i][j]=(s[i]==s[j]&&(j-i<2||f[i+1][j-1]));//dp equation
                if(maxlen<=(j-i+1)&&f[i][j]){
                    maxlen=j-i+1;
                    start=i;
                }     
            }
        }
        return s.substr(start,maxlen);
    }
};
```



Manacher 算法解法：

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        if(s.size()==0) return "";
        string add=preProcess(s);
        int maxright=0,maxlen=0,pos=0,res=0;
        int RL[add.size()]={0};
        for(int i=0;i<add.size();i++){
            if(i<maxright)
                RL[i]=min(RL[pos*2-i],maxright-i+1);
            else
                RL[i]=1;
            while(i-RL[i]+1>=0&&RL[i]+i<=add.size()&&add[i+RL[i]]==add[i-RL[i]])
                RL[i]++;
            if(i+RL[i]-1>maxright){
                maxright=i+RL[i]-1;
                pos=i;
            }
            
            if(maxlen<=RL[i]){
                res=i;
                maxlen=RL[i];
            }
            
        }
        return s.substr((res-maxlen+1)/2,maxlen-1);
        
    }
    string preProcess(const string& s){
        int n=s.size();
        string ret="";
        for(int i=0;i<n;i++)
            ret+='#'+s.substr(i,1);
        ret+='#';
        return ret;
    }
};
```

### 11.Container With Most Water

Given *n* non-negative integers *a1*, *a2*, ..., *an *, where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

**Note: **You may not slant the container and *n* is at least 2.

 

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

**Example:**

```
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```

#### 解析

从左右两端开始往中间走，每次都移动矮的那一方，并且遇到比自己矮的仍然继续走，遇到比自己高的便计算一次面积，与当前最大面积做对比。

#### 代码

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size()-1;
        int l = left;
        int r = right;
        int max = 0;
        while(l < r)
        {
            if(height[l] < height[left] || height[r] < height[right])
            {
                if(height[l] > height[r])
                {
                    r--;
                }
                else
                {
                    l++;
                }
                continue;
            }
            int high = height[l] > height[r] ? height[r] : height[l];
            int size = high * (r - l);
            if(max < size)
            {
                left = l;
                right = r;
                max = size;
            }
            if(height[l] > height[r])
                {
                    r--;
                }
            else
                {
                    l++;
                }
            
        }
        return max;
    }
};
```

代码2

使用更简洁的解法（由于没有判断与前面的高矮，速度上面慢了一些）。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res=0;
        int start=0;
        int end=height.size()-1;
        while(start<end)
        {
            //取决于短板
            int area=min(height[start],height[end])*(end-start);
            res = max(res,area);
            if(height[start]<height[end])
                start++;
            else
                end--;
        }
        return res;
    }
};
```

### 13.Roman to Integer

Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.

```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

```

For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:

- `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. 
- `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. 
- `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.

Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

**Example 1:**

```
Input: "III"
Output: 3

```

**Example 2:**

```
Input: "IV"
Output: 4

```

**Example 3:**

```
Input: "IX"
Output: 9

```

**Example 4:**

```
Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.


```

**Example 5:**

```
Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```

#### 代码

```cpp
class Solution {
private:
    unordered_map<char,int> chmap;
public:
    int romanToInt(string s) {
        chmap['I']=1;
        chmap['V']=5;
        chmap['X']=10;
        chmap['L']=50;
        chmap['C']=100;
        chmap['D']=500;
        chmap['M']=1000;
        int res=0;
        for(int i=0;i<s.size();){
            if(i+1<s.size()&&chmap[s[i]]<chmap[s[i+1]]){
                res+=chmap[s[i+1]]-chmap[s[i]];
                i+=2;
            }
            else{
                res+=chmap[s[i]];
                i++;
            }
        }
        return res;
        
    }
};
```

### 14.Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

**Example 1:**

```
Input: ["flower","flow","flight"]
Output: "fl"


```

**Example 2:**

```
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.


```

**Note:**

All given inputs are in lowercase letters `a-z`.

#### 解析

以第一个string为基准，其他string相同位置与之对比。

#### 代码

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
        for(int i=0;i<strs[0].size();i++){
            for(int j=1;j<strs.size();j++){
                if(strs[0][i]!=strs[j][i])
                    return strs[0].substr(0,i);
            }
            
        }
        return strs[0];
    }
};
```

### 15.3Sum

Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:**

The solution set must not contain duplicate triplets.

**Example:**

```python
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
```

#### 解析

先排序，然后a从0循环到n，对于每一次循环 b=a+1,c指向最后一个数，然后b和c不断逼近，即和小于目标值，则b++，和大于目标值，则c--，注意每次找到满足条件的值以后，要避免后面的重复值。

#### 代码

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        if(nums.size()<3)
            return res;
        sort(nums.begin(),nums.end());
        auto last = nums.end();
        const int target=0;
        for(auto i=nums.begin();i<last-2;i++){//i小于last-2是因为最后i指向倒数第三个数
            if(i>nums.begin()&&*i==*(i-1))
                continue;
            auto j=i+1;
            auto k=last-1;
            while(j<k){
                if(*i+*j+*k>target){
                    k--;
                    
                }
                else if(*i+*j+*k<target){
                    j++;
                    
                }
                else{
                    res.push_back({*i,*j,*k});
                    j++;
                    k--;
                    while(*j==*(j-1)&&*k==*(k+1)&&j<k)j++;/*避免后面的重复值，如不加这一句，会有重复值，例[-2,0,0,2,2]，不加这一句结果会是[[-2,0,2],[-2,0,2]]，重复了会报错*/
                    
                    
                }
            }
            
        }
        return res;
    }
};
```

### 17. Letter Combinations of a Phone Number

Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![png](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)

**Example 1:**

```
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**Example 2:**

```
Input: digits = ""
Output: []
```

#### **Example 3:**

```
Input: digits = "2"
Output: ["a","b","c"]
```

#### Solutions

use DFS.

#### Code

```c++
class Solution {
private:
    const vector<string> maps = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    void dfs(string& digits, string& path, int index, vector<string>& res) {
        if (index == digits.size()) {
            res.push_back(path);
            return;
        }
        for (auto item : maps[digits[index]-'2']) {
            path.push_back(item);
            dfs(digits, path, index + 1, res);
            path.pop_back();
        }
    }
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) return {};
        vector<string> res;
        string path;
        dfs(digits, path, 0, res);
        return res;
    }
};
```
### 19.Remove Nth Node From End of List

Given a linked list, remove the *n*-th node from the end of list and return its head.

**Example:**

```
Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.


```

**Note:**

Given *n* will always be valid.

**Follow up:**

Could you do this in one pass?

#### 解析

找到倒数第n个指针，一次遍历实现，可以设置两个指针p1，p2，p2先走n步，然后再一起走，p2指向最后一个结点时，p1->next为需要删除的结点，注意需要删除头结点的特殊情况，依然是新建一个结点放在最前面。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode dummy{0};
        dummy.next=head;
        ListNode* p1=&dummy;
        ListNode* p2=&dummy;
        
        for(int i=0;i<n;i++)
            p2=p2->next;
        while(p2->next){
            p1=p1->next;
            p2=p2->next;
        }
        ListNode* tmp=p1->next;
        p1->next=p1->next->next;
        delete tmp;
        return dummy.next;
    }
};
```

### 20.Valid Parentheses

Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.

Note that an empty string is also considered valid.

**Example 1:**

```
Input: "()"
Output: true


```

**Example 2:**

```
Input: "()[]{}"
Output: true


```

**Example 3:**

```
Input: "(]"
Output: false


```

**Example 4:**

```
Input: "([)]"
Output: false


```

**Example 5:**

```
Input: "{[]}"
Output: true
```

#### 解析

既可以用stack保存左边的符号，也可以用string（因为有pop_back方法）。

#### 代码

```cpp
class Solution {
public:
    bool isValid(string s) {
        if(s.empty()) return true;
        unordered_map<char,char> index;
        index['(']=')';
        index['[']=']';
        index['{']='}';
        string res="";
        for(auto i=s.begin();i!=s.end();i++){
            if(*i=='('||*i=='{'||*i=='['){
                res+=*i;
            }
            else{
                if(index[*(res.end()-1)]!=*i){
                    return false;
                }
                else{
                    res.pop_back();
                }
            }
        }
        return res.empty();
    }
};
```

### 21.Merge Two Sorted Lists

Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Example:**

```
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode dummy(-1);
        ListNode* res=&dummy;
        if(!l1) return l2;
        if(!l2) return l1;
        while(l1&&l2){
            if(l1->val>l2->val){
                res->next=l2;
                l2=l2->next;
            }
            else{
                res->next=l1;
                l1=l1->next;
            }
            res=res->next;
        }
        if(l1){
            res->next=l1;
        }else if(l2){
            res->next=l2;
        }
        return dummy.next;
    }
};
```

### 22.Generate Parentheses

Given *n* pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given *n* = 3, a solution set is:

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

#### 解析

小括号生成可以用递归解决，一步一步构造字符串，当左括号数量大于0时，可以放置新的左括号，当右括号数大于0并且右括号数量小于左括号数量的时候，可以放置新的右括号。

#### 代码

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        if(n<=0)
        {
            return res;
        }
        string s;
        generate(res,n,n,s);
        return res;
    }
    void generate(vector<string>& res,int left,int right,string s)
    {
        if(left==0&&right==0)
        {
            res.push_back(s);
        }
        if(left>0)
        {
            generate(res,left - 1,right,s+"(");
        }
        if(right>0&&left<right)
        {
            generate(res,left,right-1,s+")");
        }
    }
};
```

### 23.Merge k Sorted Lists

Merge *k* sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

**Example:**

```
Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```

#### 解析

可以复用[之前一题](https://github.com/starFalll/LeetCode/blob/master/algorithms/21.Merge%20Two%20Sorted%20Lists.md)的代码。时间复杂度为O(n1+n2+n3+....)。

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
private:
    ListNode* mergeLists(ListNode* p1,ListNode* p2)
    {
        if(!p1) return p2;
        if(!p2) return p1;
        ListNode dummy(-1);
        ListNode* res=&dummy;   
        while(p1&&p2){
            if(p1->val>p2->val){
                res->next=p2;
                p2=p2->next;
            }
            else{
                res->next=p1;
                p1=p1->next;
            }
            res=res->next;
        }
        if(p1){
            res->next=p1;
        }else if(p2){
            res->next=p2;
        }
        return dummy.next;
    }
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty()) return nullptr;
        ListNode* p=lists[0];
        for(int i=1;i<lists.size();i++){
            p=mergeLists(p,lists[i]);
        }
        return p;
    }
    
};
```

### 24.Swap Nodes in Pairs

Given a linked list, swap every two adjacent nodes and return its head.

**Example:**

```
Given 1->2->3->4, you should return the list as 2->1->4->3.

```

**Note:**

- Your algorithm should use only constant extra space.
- You may **not** modify the values in the list's nodes, only nodes itself may be changed.

#### 解析

链表可以有奇数个结点。

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head||!head->next)
            return head;
        ListNode* p=head;
        ListNode* tmp=nullptr;
        head=p->next;
        while(p&&p->next){
            tmp=p->next->next;
            p->next->next=p;
            p->next=tmp;
            if(p->next&&p->next->next){
                p->next=p->next->next;
            }
            p=tmp;
        }
        return head;
        
    }
};
```

### 25.Reverse Nodes in k-Group

Given a linked list, reverse the nodes of a linked list *k* at a time and return its modified list.

*k* is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of *k* then left-out nodes in the end should remain as it is.


**Example:**

Given this linked list: `1->2->3->4->5`

For *k* = 2, you should return: `2->1->4->3->5`

For *k* = 3, you should return: `3->2->1->4->5`

**Note:**

- Only constant extra memory is allowed.
- You may not alter the values in the list's nodes, only nodes itself may be changed.

#### 解析

1. Recursion

2. Iteration

#### 代码

```cpp
// Recursion
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if(!head||!head->next||k<2) return head;
        ListNode* next_group=head;
        for(int i=0;i<k;i++){
            if(next_group)
                next_group=next_group->next;
            else
                return head;
        }
        ListNode* new_next_group=reverseKGroup(next_group,k);
        ListNode* prev=nullptr;
        ListNode* cur=head;
        ListNode* Next=head;
        while(cur!=next_group){
            Next=Next->next;
            cur->next=prev?prev:new_next_group;
            prev=cur;
            cur=Next;
        }
        return prev;
        
    }
};
```

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        if (!head || !head->next) return head;
        ListNode dummy(0, head);
        auto cur = head;
        ListNode* prev = &dummy;
        while (true) {
            auto next_node = cur;
            int num = 0;
            while (num < k && next_node) {
                next_node = next_node->next;
                num++;
            }
            if (num < k) {
                if (prev) prev->next = cur;
                return dummy.next;
            }
            auto node = cur;
            ListNode* new_prev = nullptr;
            for (int i = 0; i < k; i++) {
                auto tmp = node->next;
                node->next = new_prev;
                new_prev = node;
                node = tmp;
            }
            if (prev) prev->next = new_prev;
            prev = cur;
            cur = next_node;
        }
    }
};
```

### 31.Next Permutation

Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be **in-place** and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

#### 解析

遇到这类概念比较抽象的题目，写几个例子通常会帮助理解问题的规律：

7 2 5 2 3 1

7 2 5 3 1 2

7 2 5 3 2 1

7 3 1 2 2 5

由此可知：

**1. 从低位向高位（从右向左）找第一个递减的数：s[i]>s[i-1]。如果不存在，则表明该permutation已经最大，next permutation为当前序列的逆序。**

**2. 在s[i:n-1]中找一个j，使s[j]为大于s[i]的最小数，swap(s[i], s[j])**

**3. 将s[i:n-1]反转。**

#### 代码

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        for(int i=nums.size()-1;i>0;i--){
            if(nums[i]>nums[i-1]){
                int j=i;
                while(j<nums.size()&&nums[j]>nums[i-1])
                    j++;
                swap(nums[i-1],nums[--j]);
                reverse(nums.begin()+i,nums.end());
                return;
            }
        }
        reverse(nums.begin(),nums.end());
        return;
    }

    void swap(int & a,int &b){
        int tmp=a;
        a=b;
        b=tmp;
    }
};
```

### 32.Longest Valid Parentheses

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid (well-formed) parentheses substring.

**Example 1:**

```
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"


```

**Example 2:**

```
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

#### 解析

1. 从头到尾扫描字符串。
2. 如果当前字符是 '('，将其下标 push 到堆栈。如果当前字符是 ')' 并且堆栈顶部索引处的字符是 '('，我们找到一匹配的字符串，所以从堆栈弹出。否则，我们将 ')' 的下标 push 到堆栈。
3. 扫描完成后，堆栈将只包含无法匹配的字符下标。观察可以发现：相邻下标之间的子串应该是有效的括号。
4. 如果堆栈为空，则整个输入字符串有效。否则，我们可以扫描堆栈以获得最长的有效子字符串，如步骤3中所述。

#### 代码

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        if(s.empty()) return 0;
        stack<int> lefts;
        int longest=0;
        for(int i=0;i<s.size();i++){
            if(s[i]=='(') lefts.push(i);
            else{
                if(!lefts.empty()&&s[lefts.top()]=='(')
                    lefts.pop();
                else
                    lefts.push(i);
            }
        }
        if(lefts.empty()) 
            longest=s.size();
        else{
            int a=s.size(),b=0;
            while(!lefts.empty()){
                b=lefts.top();lefts.pop();
                longest=max(longest,a-b-1);
                a=b;
            }
            longest=max(longest,a);
        }
        return longest;
        
    }
};
```

### 33.Search in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).

You are given a target value to search. If found in the array return its index, otherwise return `-1`.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

#### 代码1

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size()==0)
            return -1;
        if(nums.size()==1){
            if(nums[0]==target)
                return 0;
            return -1;
        }
        int low=0,high=nums.size()-1;
        while(low<=high){
            int mid = low + (high -low)/2;
            if(target==nums[mid]){
                return mid;
            }

            else if(nums[mid]>=nums[low]){/*中间的数为大数，例4,5,6,7,0,1,2，这里要有等号，因为是向下取整*/
                if(target<nums[mid]&&target>=nums[low])/*这种情况下low~mid为递增数列，又因为是大数，所以看左边这截*/
                    high=mid-1;
                else{
                    low=mid+1;
                }
            }
            else{//中间的数为小数，例5,6,7,0,1,2,4
                if(target>nums[mid]&&target<=nums[high])/*这种情况下mid~high为递增数列，又因为是小数，所以看右边这截*/
                    low=mid+1;
                else{
                    high=mid-1;
                }
            }
            
        }
        return -1;
    }
};
```

### 34.Find First and Last Position of Element in Sorted Array

Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

If the target is not found in the array, return `[-1, -1]`.

**Example 1:**

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

```

**Example 2:**

```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```

#### 解析

使用二分法。

#### 代码

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> res={-1,-1};
        if(nums.empty()) return res;
        if(target<nums[0]||target>nums[nums.size()-1]) return res;
        int low=0,high=nums.size()-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(target<nums[mid]){
                high=mid-1;
            }
            else if(target>nums[mid]){
                low=mid+1;
            }
            else{
                high=mid-1;
                res[0]=mid;
            }
        }
        low=0,high=nums.size()-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(target<nums[mid]){
                high=mid-1;
            }
            else if(target>nums[mid]){
                low=mid+1;
            }
            else{
                low=mid+1;
                res[1]=mid;
            }
        }
        return res;
    }
};
```

### 35.Search Insert Position

Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

**Example 1:**

```
Input: [1,3,5,6], 5
Output: 2


```

**Example 2:**

```
Input: [1,3,5,6], 2
Output: 1


```

**Example 3:**

```
Input: [1,3,5,6], 7
Output: 4


```

**Example 4:**

```
Input: [1,3,5,6], 0
Output: 0
```

#### 解析

可以顺序遍历，也可以二分法。对于二分法来说，终止条件是 `low>high`，又因为目标值在 [low,high+1] 之内，所以 `low<=high+1`，综上我们知道 `[low, high+1] = [low, low]`，所以 low 就是目标值的下标。

#### 代码

顺序遍历：

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        for(int i=0;i<nums.size();i++){
            if(nums[i]==target)
                return i;
            else if(nums[i]>target)
                return i;
        }
        return nums.size();
    }
};
```

二分法：

```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low=0,high=nums.size()-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(nums[mid]==target)
                return mid;
            else if(nums[mid]>target)
                high=mid-1;
            else
                low=mid+1;
        }
        return low;
    }
};
```

### 39.Combination Sum

Given a **set** of candidate numbers (`candidates`) **(without duplicates)** and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.

The **same** repeated number may be chosen from `candidates` unlimited number of times.

**Note:**

- All numbers (including `target`) will be positive integers.
- The solution set must not contain duplicate combinations.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]

```

**Example 2:**

```
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```

#### 解析

使用DFS，从左到右，每次选一个值，与其本身及后面的值再次进行DFS，如果求和等于target就插入结果，如果大于就返回上一层。

#### 代码

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> vec;
        if(candidates.empty()||target<=0) return res;
        int Sum = 0;
        combination(Sum, res, candidates, vec, target, 0);
        unique(res.begin(), res.end());
        return res;
    }
    
    void combination(int& sum, vector<vector<int>>& res,const vector<int>& candidates, vector<int>& vec, const int& target, int start)
    {
        if(sum == target)
        {
            res.push_back(vec);
            return;
        }
        else if(sum > target) return;
        for(int i = start; i < candidates.size();++i)
        {
            sum+=candidates[i];
            vec.push_back(candidates[i]);
            combination(sum, res, candidates, vec, target, i);
            vec.pop_back();
            sum-=candidates[i];
        }
    }
};
```

### 41.First Missing Positive

Given an unsorted integer array, find the smallest missing positive integer.

**Example 1:**

```
Input: [1,2,0]
Output: 3


```

**Example 2:**

```
Input: [3,4,-1,1]
Output: 2


```

**Example 3:**

```
Input: [7,8,9,11,12]
Output: 1


```

**Note:**

Your algorithm should run in *O*(*n*) time and uses constant extra space.

#### 解析

##### 方法1

使用hash table 存储 nums 中的内容，然后顺序遍历正数，从 i 到 INT_MAX，返回第一个不在  hash table 中的数。

##### 方法2

本质上是桶排序，每当 `A[i]!=i+1` 的时候，将 `A[i]` 与 `A[A[i]-1]` 交换，也就是把每个数字放回对应的下标的位置，直到交换完，即 `A[i]==i+1`。

#### 代码

##### 方法1

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.empty()) return 1;
        unordered_map<int,bool> index;
        for(int i=0;i<nums.size();i++){
            index[nums[i]]=true;
        }
        for(int i=1;i<=INT_MAX;i++){
            if(index.find(i)==index.end()){
                return i;
            }
        }
        return -1;
    }
};
```

##### 方法2

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n=nums.size();
        for(int i=0;i<n;i++){
            while(nums[i]!=i+1){
                int tmp=nums[i];
                if(tmp<=0||tmp>n)break;
                if(nums[tmp-1]==tmp)break;
                swap(nums[tmp-1],nums[i]);
            }
        }
        for(int i=0;i<n;i++){
            if(nums[i]!=i+1) return i+1;
        }
        return n+1;
    }
};
```



### 42.Trapping Rain Water

Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![img](http://www.leetcode.com/static/images/problemset/rainwatertrap.png)
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!

**Example:**

```
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

#### 解析

方法一：

双指针。

对于每个柱子（高为height），找到其左右最高的柱子（left_max,right_max），上面的积水为：max(left_max,right_max)-height.

具体方法：

找到最高的柱子，然后从左到最高和从右到最高依次遍历。

方法二：

单调栈。

相同高度的保留最新的在栈内。



#### 代码

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int max=0;
        for(int i=0;i<height.size();i++){
            if(height[i]>height[max])
                max=i;
        }
        int res=0;
        for(int i=0,left=0;i<max;i++){
            if(height[i]>height[left]){
                left=i;
            }
            else{
                res+=height[left]-height[i];
            }
        }
        for(int i=height.size()-1,right=height.size()-1;i>max;i--){
            if(height[i]>height[right]){
                right=i;
            }
            else{
                res+=height[right]-height[i];
            }
        }
        return res;

    }
};
```

```cpp
// 单调栈
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        stack<int> s;
        int begin = 0;
        while (begin < height.size()) {
            if (height[begin] == 0) begin++;
            else break;
        }
        if (begin == height.size()) return res;
        for (int i = begin; i < height.size(); i++) {
            int val = height[i];
            // beacause same height choose rightmost index, so cur situation must be a 凹 shape.
            while (!s.empty() && val > height[s.top()]) {
                int mid = height[s.top()];
                s.pop();
                if (!s.empty()) {
                    res += (min(height[s.top()], val) -  mid) * (i - s.top() - 1);
                }
            }
            // same height choose rightmost index
            if (!s.empty() && val == height[s.top()]) s.pop();
            s.push(i);
        }
        return res;
    }
};

```
### 45.Jump Game II

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

**Example:**

```
Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

#### 解析

和上一题类似，采用贪心算法。比如[2,3,1,1,4]，第一个最多可以走两步，即[2,3,1]为第一个区间，[1,1,4]为第二个区间，所以用last记录上一个区间的最远值，用cur更新最远值。

#### 代码

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size()<=1) return 0;
        int last = 0;
        int cur = 0;
        int step = 0;
        for(int i=0;i<nums.size();++i)
        {
          	//走到超过上一次更新的最远值才重新更新最远值
            if(i > last)
            {
                last = cur;
                ++step;
            }
            cur = max(cur,i+nums[i]);
        }
        return step;
        
    }
};
```

### 46.Permutations

Given a collection of **distinct** integers, return all possible permutations.

**Example:**

```
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

#### 解析

和 subset 差不多的解决方法，都是使用回溯法。

#### 代码

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> path;
        dfs(nums,path,res);
        return res;
    }
    void dfs(vector<int>& nums,vector<int>& path,vector<vector<int>>& res)
    {
        if(path.size()==nums.size()){
            res.push_back(path);
            return;
        }
        for(auto i:nums){
            auto pos=find(path.begin(),path.end(),i);
            if(pos==path.end()){
                path.push_back(i);
                dfs(nums,path,res);
                path.pop_back();
            }
        }
    }
};
```

###  48.Rotate Image

You are given an *n* x *n* 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

**Note:**

You have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

```
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]


```

**Example 2:**

```
Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

#### 代码

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        for(int i=0;i<matrix.size()-1;i++){//diagonal exchange
            for(int j=0;j+i<matrix.size()-1;j++){
                swap(matrix[i][j],matrix[matrix.size()-1-j][matrix.size()-1-i]);
            }
        }
        
        for(int i=0;i<matrix.size();i++){//horizontal exchange
            for(int j=0;j<matrix.size()/2;j++){
                swap(matrix[j][i],matrix[matrix.size()-1-j][i]);
            }
        }
        
    }
};
```

### 49.Group Anagrams

Given an array of strings, group anagrams together.

**Example:**

```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

#### 代码

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> strmap;
        for(auto s:strs){
            string key=s;
            sort(key.begin(),key.end());
            strmap[key].push_back(s);
        }
        vector<vector<string>> res;
        for(auto it=strmap.cbegin();it!=strmap.cend();it++){
            res.push_back(it->second);
        }
        return res;
    }
};
```

### 51.N-Queens

The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return *all distinct solutions to the **n-queens puzzle***. You may return the answer in **any order**.

Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.

**Example 1:**

![png](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
Input: n = 4
Output: [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above
```

**Example 2:**

```
Input: n = 1
Output: [["Q"]]
```

#### Solutions

**backtracking**/DFS.

#### Code

```c++
class Solution {
private:
    bool checkValid(const vector<string>& path, int col, int row) {
        for (int i = 0; i < path.size(); i++) {
            if (path[i][col] == 'Q') return false;
            int distance = abs(i-row);
            if (col - distance >= 0 && path[i][col-distance] == 'Q') return false;
            if (col + distance < path[i].size() && path[i][col+distance] == 'Q') return false;
        }
        return true;
    }
    void dfs(vector<vector<string>>& res, vector<string>& path, int n, int row) {
        if (row == n) {
            res.push_back(path);
            return;
        }
        for (int i = 0; i < n; i++) {
            string line(n, '.');
            if (checkValid(path, i, row)) {
                line[i] = 'Q';
                path.push_back(line);
                dfs(res, path, n, row + 1);
                path.pop_back();
            }
        }
    }
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> res;
        vector<string> path;
        dfs(res, path, n, 0);
        return res;
    }
};
```
### 53.Maximum Subarray

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

**Example:**

```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

#### 解析

动态规划思想，用一个变量sum存储和，如果sum值小于等于0，则sum置0，重新开始求和。

#### 代码

```cpp
// dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。
// dp[i] = max(nums[i], dp[i-1] + nums[i])
// dp[0] = nums[0]
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int dp = nums[0];
        int res = dp;
        for (int i = 1; i < nums.size(); i++) {
            dp = max(dp + nums[i], nums[i]);
            res = max(res, dp);
        }
        return res;        
    }
};
```
### 54.Spiral Matrix

Given a matrix of *m* x *n* elements (*m* rows, *n* columns), return all elements of the matrix in spiral order.

**Example 1:**

```
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]

```

**Example 2:**

```
Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]

```

#### 解析

剑指offer原题，模拟即可。

#### 代码

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> res;
        if(matrix.empty() || matrix[0].empty()) return res;
        int rows = matrix.size();
        int cols = matrix[0].size();
        spiralOnceOrder(matrix, res, 0, rows, cols);
        return res;
    }
    
    void spiralOnceOrder(vector<vector<int>>& matrix, vector<int>& res, int begin, int rows, int cols)
    {
        if(rows <= 0 || cols <= 0) return;
        for(int i=begin; i<begin+cols;++i)
        {
            res.push_back(matrix[begin][i]);
        }
        for(int i=begin+1;i<begin+rows;++i)
        {
            res.push_back(matrix[i][begin+cols-1]);
        }
        if(rows>1)
        {
            for(int i=begin+cols-2;i>=begin;--i)
            {
                res.push_back(matrix[begin+rows-1][i]);
            }
        }
        if(cols>1)
        {
            for(int i=begin+rows-2;i>begin;--i)
            {
                res.push_back(matrix[i][begin]);
            }
        }
        spiralOnceOrder(matrix, res, begin+1, rows-2,cols-2);
    }
};
```

### 55.Jump Game

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

**Example 1:**

```
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

```

**Example 2:**

```
Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
```

#### 解析

设定一个reach表示可达最远值，遍历列表，每次更新reach，如果当前index超过reach则说明无法跳完。

其实为贪心算法。

#### 代码

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int reach = 1;//能跳到的最远值
        for(int i=0;i<reach && i<nums.size();++i)
        {
            reach=max(reach,i+1+nums[i]);
        }
        return reach >= nums.size();
    }
};
```

### 56. Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return *an array of the non-overlapping intervals that cover all the intervals in the input*.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

### Solution

QuickSort + loop, time complexity is O(n*logn).

#### Code

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){return a[0] < b[0];});
        vector<vector<int>> res;
        for (auto& item : intervals) {
            if (!res.empty() && item[0] <= res.back()[1]){
                auto left = res.back()[1];
                res.back()[1] = item[1] > left ? item[1] : left;
            }
            else {
                res.push_back(item);
            }
        }
        return res;
    }
};
```
### 62.Unique Paths

A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

![img](https://leetcode.com/static/images/problemset/robot_maze.png)
Above is a 7 x 3 grid. How many possible unique paths are there?

**Note:** *m* and *n* will be at most 100.

**Example 1:**

```
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
```

**Example 2:**

```
Input: m = 7, n = 3
Output: 28
```

#### 解析

备忘录法和动态规划均可。

设状态为`f[i][j]`，表示从起点`(1,1)`到达`(i,j)`的路线条数，则状态转移方程为：

```
f[i][j]=f[i-1][j]+f[i][j-1]
```

#### 代码

备忘录法

```cpp
class Solution {
private:
    vector<vector<int>> f;
public:
    int uniquePaths(int m, int n) {
        //f[x][y] is the path (0,0)->(x,y)
        f=vector<vector<int>>(m,vector<int>(n,0));
        f[0][0]=1;
        return dfs(m-1,n-1);
    }
    int dfs(int x,int y){
        if(x<0||y<0) return 0;//illegal
        if(x==0||y==0) return f[0][0];//end
        if(f[x][y]>0){
            return f[x][y];
        }else{
            return f[x][y]=dfs(x-1,y)+dfs(x,y-1);
        }

    }
};
```

动态规划

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> f(n,0);
        f[0]=1;
        for(int i=0;i<m;i++){
            for(int j=1;j<n;j++){
                f[j]=f[j]+f[j-1];
            }
        }
        return f[n-1];
    }
};
```



```cpp
// dp[i][j] the number of possible unique paths that the robot can take to reach (i, j)
// dp[i][j] = dp[i-1][j] + dp[i][j-1]
// dp[i][0] = 1, dp[0][j] = 1
// i from 0 to m-1 {j from 0 to n-1}
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i != 0 && j != 0) dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```
### 64.Minimum Path Sum

Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

**Example:**

```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```

#### 解析

动态规划。

#### 代码

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size()<1||grid[0].size()<1) return 0;
        
        for(int i=0;i<grid.size();++i)
        {
            for(int j=0;j<grid[0].size();++j)
            {
                if(i==0&&j==0) continue;
                int left=j>0?grid[i][j-1]:INT_MAX;
                int head=i>0?grid[i-1][j]:INT_MAX;
                grid[i][j]+=min(left,head);
            }
        }
        return grid[grid.size()-1][grid[0].size()-1];
    }
};
```

### 70.Climbing Stairs

You are climbing a stair case. It takes *n* steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note:** Given *n* will be a positive integer.

**Example 1:**

```
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps


```

**Example 2:**

```
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

#### 解析

[斐波那契数列](https://zh.wikipedia.org/zh/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97) 的一种变体，和[青蛙跳台阶（剑指offer原题）](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)是一模一样的题。

#### 代码

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n<0)
            return -1;
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        int a=1;
        int b=1;
        for(int i=2;i<=n;i++){
            b=a+b;
            a=b-a;
        }
        return b;
    }
};
```

### 72. Edit Distance

Given two strings `word1` and `word2`, return *the minimum number of operations required to convert `word1` to `word2`*.

You have the following three operations permitted on a word:

- Insert a character
- Delete a character
- Replace a character

**Example 1:**

```
Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation: 
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')**Example 2:**
```

**Example 2**

```
Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation: 
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```

### Solution

Dynamic programming.

Set `dp[i][j]`, i is length of word1, j is length of word2, `dp[i][j]` means the minimum edit distance from word1 to word2.

```
// dp[i][j]
// delete word2 dp[i][j] = dp[i][j-1]
// replace dp[i][j] = dp[i-1][j-1]
// delete word1 == insert word2 delete dp[i][j] = dp[i-1][j]   (eg word1="ab", word2="a", word1 delete  = "a" or word2 insert = "ab")
// dp[i][j] =  min(min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + 1) if word1[i-1] != word2[j-1] else dp[i-1][j-1]
// dp[0][0] = 0;
// dp[0][j] = j;dp[i][0] = i;
```

The function is:

![png](https://images2015.cnblogs.com/blog/630246/201706/630246-20170629233505368-427461068.png)

#### Code

```c++
// space O(n^2)
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 1; i <= word1.size(); i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i <= word2.size(); i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= word1.size(); i++)
            for (int j = 1; j <= word2.size(); j++) {
                if (word1[i-1] == word2[j-1]) {
                    dp[i][j] = dp[i-1][j-1];
                }
                else {
                    dp[i][j] = 1 + min(min(dp[i-1][j-1], dp[i][j-1]), dp[i-1][j]);
                }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

```C++
// space O(n)
// bacause only need three old values
// need a tmp to store the dp[i][j-1]
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<int> dp(word2.size() + 1, 0);
        for (int i = 1; i <= word2.size(); i++) {
            dp[i] = i;
        }
        for (int i = 1; i <= word1.size(); i++){
            int old = dp[0];
            dp[0] = i;
            for (int j = 1; j <= word2.size(); j++) {
                int tmp = dp[j];
                if (word1[i-1] == word2[j-1]) {
                    dp[j] = old;
                }
                else {
                    dp[j] = 1 + min(min(dp[j-1], dp[j]), old);
                }
                old = tmp;
            }
        }

        return dp[word2.size()];
    }
};
```
### 73.Set Matrix Zeroes

Given a *m* x *n* matrix, if an element is 0, set its entire row and column to 0. Do it [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm).

**Example 1:**

```
Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]


```

**Example 2:**

```
Input: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]


```

**Follow up:**

- A straight forward solution using O(*m**n*) space is probably a bad idea.
- A simple improvement uses O(*m* + *n*) space, but still not the best solution.
- Could you devise a constant space solution?

#### 解析

O(1)可以用第一行和第一列来存储，中间有任何一个数为0，则将其对应的第一行和第一列的数设为0即可，此外，在此之前需要分别遍历一次第一行和第一列，用两个布尔常量判断是否需要将第一行和第一列设为0.

#### 代码

```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        bool first_col = false, first_row = false;
        for (int i = 0 ; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                    if (i == 0) first_row = true;
                    if (j == 0) first_col = true;
                }
            }
        }
        for (int j = 1; j < n; j++) {
            if (matrix[0][j] == 0) {
                for (int i = 0; i < m; i++) {
                    matrix[i][j] = 0;
                }
            }
        }

        for (int i = 1 ; i < m; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 0; j < n; j++) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (first_row) {
            for (int j = 0; j < n; j++) matrix[0][j] = 0;
        }
        if (first_col) {
            for (int i = 0; i < m; i++) matrix[i][0] = 0;
        }
    }
};
```

### 74.Search a 2D Matrix

Write an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:

- Integers in each row are sorted from left to right.
- The first integer of each row is greater than the last integer of the previous row.

**Example 1:**

```
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true


```

**Example 2:**

```
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
```

#### 解析

先找到目标值所在的行再用二分法查找。

#### 代码

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty()||matrix[0].empty()) return false;
        int row=-1;
        int n=matrix[0].size()-1;
        for(int i=0;i<matrix.size();i++){
            if(matrix[i][n]>=target){
                row=i;
                break;
            }
        }
        if(row<0)return false;
        int low=0,high=matrix[row].size()-1;
        while(low<=high){
            int mid=low+(high-low)/2;
            if(matrix[row][mid]==target){
                return true;
            }
            else if(matrix[row][mid]>target)
                high=mid-1;
            else
                low=mid+1;
        }
        return false;
    }
};
```

### 75.Sort Colors

Given an array with *n* objects colored red, white or blue, sort them **in-place **so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

**Note:** You are not suppose to use the library's sort function for this problem.

**Example:**

```
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

```

**Follow up:**

- A rather straight forward solution is a two-pass algorithm using counting sort.
  First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
- Could you come up with a one-pass algorithm using only constant space?

#### 解析

设置两个index，最开始一个位于头部，一个位于尾部，变量 i 从0开始遍历如果指向的内容是2则 i 和尾部交换，尾部往前走；如果 i 指向 0，则和头部交换，头部往后走。

#### 代码

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int zero = 0;
        int second = nums.size()-1;
        for(int i = 0; i <= second; i++)
        {
            while (nums[i] == 2 && i < second) {
                swap(nums[i], nums[second--]);
            }
            while (nums[i] == 0 && i > zero)
            {
                swap(nums[i], nums[zero++]);
            }
        }
    }
};
```



### 76. Minimum Window Substring

Given two strings `s` and `t` of lengths `m` and `n` respectively, return *the **minimum window*** 

***substring***

 *of* `s` *such that every character in* `t` *(**including duplicates**) is included in the window*. If there is no such substring, return *the empty string* `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
```

### Solution

slide windows.

[[LeetCode] 76. Minimum Window Substring 最小窗口子串 - Grandyang - 博客园](https://www.cnblogs.com/grandyang/p/4340948.html)

#### Code

```c++
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.size() < t.size()) return "";
        vector<int> tables(128, 0);
        for (auto& ch : t) tables[ch]++;
        int minLen = INT_MAX;
        int left = 0, cnt = 0, minLeft = -1;
        for (int i = 0; i < s.size(); i++) {
            if (--tables[s[i]] >= 0) cnt++;
            while (cnt == t.size()) {
                if (i - left + 1 < minLen) {
                    minLen = i - left + 1;
                    minLeft = left;
                }
                if (++tables[s[left]] > 0) {
                    cnt--;
                }
                left++;
            }
        }
        return minLeft >= 0 ? s.substr(minLeft, minLen) : "";
    }
};
```
### 78.Subsets

Given a set of **distinct** integers, *nums*, return all possible subsets (the power set).

**Note:** The solution set must not contain duplicate subsets.

**Example:**

```
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

```

#### 解析

##### 递归法

使用增量构造的方法，每个元素都有两种选择，选或者不选。

##### 迭代法I

使用二进制法，本方法的前提是：集合的元素不超过int位数。用一个int整数表示位向量，第`i`位为1，则表示选择`S[i]`，为0则不选择。例如 `S={A,B,C,D}`，则`0110=6`表示子集 `{B,C}`。

这种方法最巧妙。因为它不仅能生成子集，还能方便的表示集合的并、交、差等集合运算。设两个集合的位向量分别为B_1和B_2，则$B_1\cup B_2, B_1 \cap B_2, B_1 \triangle B_2B1∪B2,B1∩B2,B1△B2$分别对应集合的并、交、对称差。

二进制法，也可以看做是位向量法，只不过更加优化。

##### 迭代法II

起始subset集为：[]
添加S0后为：[], **[S0]**
添加S1后为：[], [S0], **[S1], [S0, S1]**
添加S2后为：[], [S0], [S1], [S0, S1],** [S2], [S0, S2], [S1, S2], [S0, S1, S2]**
红加粗subset为每次新增的。显然规律为添加Si后，新增的subset为克隆现有的所有subset，并在它们后面都加上Si。

#### 代码

##### 递归法

```cpp
class Solution {
private:
    void subset(const vector<int>& S,vector<int>& path,int step,vector<vector<int>>& res)
    {
        if(step==S.size()){
            res.push_back(path);
            return;
        }
        //not choose S[step]
        subset(S,path,step+1,res);
        //choose S[step]
        path.push_back(S[step]);
        subset(S,path,step+1,res);
        path.pop_back();
        return;
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        vector<int> path;
        subset(nums,path,0,res);
        return res;
    }
};
```

##### 迭代法I

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        vector<int> line;
        const int n=nums.size();
        for(int i=0;i<(1<<n);i++){
            for(int j=0;j<n;j++){
                if(i&(1<<j)) line.push_back(nums[j]);
            }
            res.push_back(line);
            line.clear();
        }
        return res;
    }
};
```

##### 迭代法II

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        res.push_back(tmp);
        sort(nums.begin(),nums.end());
        for(int i=0;i<nums.size();i++){
            int n=res.size();
            for(int j=0;j<n;j++){
                tmp=res[j];
                tmp.push_back(nums[i]);
                res.push_back(tmp);
            }
        }
        return res;
    }
};
```

### 79.Word Search

Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

**Example:**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```

#### 解析

回溯法。

#### 代码

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if(board.empty()||board[0].empty()) return false;
        vector<vector<int>> visited(board.size(), vector<int>(board[0].size(), 0));
        for(int i=0;i<board.size();++i)
        {
            for(int j=0;j<board[i].size();++j)
            {
                if(board[i][j]==word[0])
                {
                    if(exist(board,word, i, j, 0, visited))
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    bool exist(vector<vector<char>>& board, string& word, int col, int row, int index, vector<vector<int>>& visited)
    {
        if(index==word.size())
        {
            return true;
        }

        if(col<0||col>=board.size()||row<0||row>=board[col].size()||visited[col][row]==1||board[col][row] != word[index])
        {
            return false;
        }
        visited[col][row]=1;
        
        if(exist(board,word,col+1,row,index+1,visited)
          ||exist(board,word,col,row+1,index+1,visited)
          ||exist(board,word,col,row-1,index+1,visited)
          ||exist(board,word,col-1,row,index+1,visited))
        {
            return true;
        }
        else{
            visited[col][row]=0;
            return false;
        }
    }
};
```

### 84.Largest Rectangle in Histogram

Given *n* non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

![img](https://leetcode.com/static/images/problemset/histogram.png)
Above is a histogram where width of each bar is 1, given height = `[2,1,5,6,2,3]`.

![img](https://leetcode.com/static/images/problemset/histogram_area.png)
The largest rectangle is shown in the shaded area, which has area = `10` unit.

**Example:**

```
Input: [2,1,5,6,2,3]
Output: 10
```

#### 解析

这道题目算是比较难的一道题目了，首先最简单的做法就是对于任意一个bar，向左向右遍历，直到高度小于该bar，这时候计算该区域的矩形区域面积。对于每一个bar，我们都做如上处理，最后就可以得到最大值了。当然这种做法是O(n^2)，过不了大数据集合测试。

从上面我们直到，对于任意一个bar n，我们得到的包含该bar n的矩形区域里面bar n是最小的。我们使用ln和rn来表示bar n向左以及向右第一个小于bar n的bar的索引位置。

譬如题目中的bar 2的高度为5，它的ln为1，rn为4。包含bar 2的矩形区域面积为(4 - 1 - 1) * 5 = 10。

我们可以从左到右遍历所有bar，并将其push到一个stack中，如果当前bar的高度小于栈顶bar，我们pop出栈顶的bar，同时以该bar计算矩形面积。那么我们如何知道该bar的ln和rn呢？rn铁定就是当前遍历到的bar的索引，而ln则是当前的栈顶bar的索引，因为此时栈顶bar的高度一定小于pop出来的bar的高度。

为了更好的处理最后一个bar的情况，我们在实际中会插入一个高度为0的bar，这样就能pop出最后一个bar并计算了。

```cpp
// similar with Leetcode 42
// 单调栈
// 42. 接雨水 (opens new window)是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。
// 即求每个柱子包含它自己的最大面积，则需要找到其左右比它小的柱子（比它大面积肯定覆盖它了）
```

#### 代码

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.empty()) return 0;
        stack<int> res;
        heights.push_back(0);
        int result=0;
        for(int i=0;i<heights.size();){
            if(res.empty()||heights[i]>heights[res.top()])
                res.push(i++);
            else{
                int tmp=res.top();
                res.pop();
                result=max(result,heights[tmp]*(res.empty()?i:i-res.top()-1));
            }
        }
        return result;
    }
};

// 单调栈解法。
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> s;
        int res = 0;
        // to count last part
        heights.push_back(0);
        heights.insert(heights.begin(), 0);
        for (int i = 0; i < heights.size(); i++) {
            while (!s.empty() && heights[s.top()] > heights[i]) {
                int mid = heights[s.top()];
                s.pop();
                if (!s.empty()) {
                    res = max(res, (i - s.top() - 1) * mid);
                }
            }
            s.push(i);
        }
        return res;
    }
};
```
### 94.Binary Tree Inorder Traversal

Given a binary tree, return the *inorder* traversal of its nodes' values.

**Example:**

```
Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
```

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        if(!root) return res;
        vector<int> tmp1=inorderTraversal(root->left);
        res.insert(res.end(),tmp1.begin(),tmp1.end());
        res.push_back(root->val);
        vector<int> tmp2=inorderTraversal(root->right);
        res.insert(res.end(),tmp2.begin(),tmp2.end());
        return res;
    }
};
```

### 98.Validate Binary Search Tree

Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys **less than** the node's key.
- The right subtree of a node contains only nodes with keys **greater than** the node's key.
- Both the left and right subtrees must also be binary search trees.

**Example 1:**

```
Input:
    2
   / \
  1   3
Output: true


```

**Example 2:**

```
    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.
```

#### 解析

BST中序遍历顺序的结点数值是递增的，可以利用这个特性求解。

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        TreeNode* prev=nullptr;
        return isValidBST(root,prev);
    }
    bool isValidBST(TreeNode* root,TreeNode*& prev)//inorder
    {
        if(!root) return true;
        if(!isValidBST(root->left,prev)) return false;
        if(prev&&prev->val>=root->val) return false;//if inorder not increment,false
        prev=root;
        return isValidBST(root->right,prev);
        
    }
};
```

### 101.Symmetric Tree

Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:

```
    1
   / \
  2   2
 / \ / \
3  4 4  3


```

But the following `[1,2,2,null,3,null,3]` is not:

```
    1
   / \
  2   2
   \   \
   3    3
```

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return isSymmetric(root->left,root->right);
    }
    bool isSymmetric(TreeNode* p,TreeNode* q)
    {
        if(!p&&!q) return true;
        if(!p||!q) return false;
        return p->val==q->val&&isSymmetric(p->left,q->right)&&isSymmetric(p->right,q->left);
    }
    
};
```

### 102.Binary Tree Level Order Traversal

Given a binary tree, return the *level order* traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7


```

return its level order traversal as:

```
[
  [3],
  [9,20],
  [15,7]
]
```

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(!root) return res;
        queue<TreeNode*> q,next;
        q.push(root);
        while(!q.empty()){
            vector<int> line;
            while(!q.empty()){
                TreeNode* tmp=q.front();
                q.pop();
                line.push_back(tmp->val);
                if(tmp->left) next.push(tmp->left);
                if(tmp->right) next.push(tmp->right);
            }
            res.push_back(line);
            swap(q,next);
        }
        return res;
    }
};
```

### 104.Maximum Depth of Binary Tree

Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Note:** A leaf is a node with no children.

**Example:**

Given binary tree `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7

```

return its depth = 3.

#### 解析

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left),maxDepth(root->right))+1;
    }
};
```

### 105.Construct Binary Tree from Preorder and Inorder Traversal

Given preorder and inorder traversal of a tree, construct the binary tree.

**Note:**
You may assume that duplicates do not exist in the tree.

For example, given

```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]

```

Return the following binary tree:

```
    3
   / \
  9  20
    /  \
   15   7
```

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTree(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());
    }
    template<typename Input>
    TreeNode* buildTree(Input pre_first,Input pre_last,Input in_first,Input in_last)
    {
        if(pre_first==pre_last) return nullptr;
        if(in_first==in_last) return nullptr;
        auto root=new TreeNode(*pre_first);
        auto inroot=find(in_first,in_last,*pre_first);
        auto leftlen=distance(in_first,inroot);
        root->left=buildTree(pre_first+1,pre_first+1+leftlen,in_first,inroot);
        root->right=buildTree(pre_first+1+leftlen,pre_last,inroot+1,in_last);
        
        return root;
    }
};
```

### 114.Flatten Binary Tree to Linked List

Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

```
    1
   / \
  2   5
 / \   \
3   4   6


```

The flattened tree should look like:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        flatten(root,nullptr);
    }
    
    TreeNode* flatten(TreeNode* root,TreeNode* tail)
    {
        if(root==nullptr) return tail;
      	//root is list ,and tail behind it
        root->right=flatten(root->left,flatten(root->right,tail));
        root->left=nullptr;
        
        return root;
        
    }
};
```

### 118.Pascal's Triangle

Given a non-negative integer *numRows*, generate the first *numRows*of Pascal's triangle.

![img](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)
In Pascal's triangle, each number is the sum of the two numbers directly above it.

**Example:**

```
Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

#### 代码

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;
        if(numRows<=0) return res;
        for(int i=0;i<numRows;++i)
        {
            vector<int> tmp(i+1,1);
            if(tmp.size()>=3)
            {
                for(int j=1;j<tmp.size()-1;++j)
                {
                    tmp[j]=res[i-1][j-1]+res[i-1][j];
                }
            }
            res.push_back(tmp);
        }
        return res;
    }
};
```
### 121.Best Time to Buy and Sell Stock

Say you have an array for which the *i*th element is the price of a given stock on day *i*.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

**Example 1:**

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.

**Example 2:**

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
#### 解析

动态规划。`m[j]`为第 j+1 位的最大利润，如果`prices[j]`值比上一位`prices[j-1]`的值小，说明该位的最大利润会减小，减少值为值的差，但是最小不会少于0，所以可以列出动态规划的方程为：

```c++
m[0] = 0;
m[j] = (m[j-1] + prices[j] - prices[j-1]) > 0? m[j-1] + prices[j] - prices[j-1] : 0;
```

#### 代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int len = prices.size();
        vector<int> m(len, 0);
        m[0] = 0;
        int res = 0;
        for(int i=1;i<len;++i)
        {
            int tmp = m[i-1] + prices[i] - prices[i-1];
            m[i] = tmp > 0 ? tmp:0;
            if(m[i] > res)
                res = m[i];
        }
        return res;
    }
};
```

### 124.Binary Tree Maximum Path Sum

Given a **non-empty** binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain **at least one node** and does not need to go through the root.

**Example 1:**

```
Input: [1,2,3]

       1
      / \
     2   3

Output: 6


```

**Example 2:**

```
Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```

#### 解析

这道题我们可以采用dfs遍历二叉树，先算出左右树的结果 l 和 r，如果 l 大于0，那么对后续结果有利，便加上这个值，r同理，因为是一条路径，使用 dfs 返回的时只能从左右两条子树中选一条最大的与根节点的和，或者如果两个子树都是小于0的，那么便只返回根节点。

#### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
private:
    int max_sum;
    int dfs(TreeNode* root)
    {
        if(!root) return 0;
        int l=dfs(root->left);
        int r=dfs(root->right);
        int sum=root->val;
        if(l>0) sum+=l;
        if(r>0) sum+=r;
        max_sum=max(max_sum,sum);
        return max(l,r)>0?max(l,r)+root->val:root->val;
    }
public:
    int maxPathSum(TreeNode* root) {
        max_sum=INT_MIN;
        dfs(root);
        return max_sum;
    }
};
```

### 128.Longest Consecutive Sequence

Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(*n*) complexity.

**Example:**

```python
Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

#### 解析

如果允许O(nlogn)的复杂度，那么可以先排序，可是本题要求`O(n)`。

由于序列里的元素是无序的，又要求`O(n)`，首先要想到用哈希表。

用一个哈希表存储所有出现过的元素，对每个元素，以该元素为中心，往左右扩张，直到不连续为止，记录下最长的长度。

#### 代码1

```c++
//时间复杂度为O(n)
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_map<int,bool> used;
        for(auto i:nums) used[i]=false;
        
        int lengest=0;
      
        for(auto i:nums){
            if(used[i]) continue;
            int length=1;
            used[i]=true;
          /*unordered_map的find是如果找到指定的键值，则为元素的迭代器;如果在容器中未找到指定的键，则为unordered_map::end，所以用used.find(j)!=used.end()判断key是否在map内*/
            for(int j=i+1;used.find(j)!=used.end();j++){
                length++;
                used[j]=true;
            }
            for(int j=i-1;used.find(j)!=used.end();j--){
                length++;
                used[j]=true;
            }
            lengest=max(lengest,length);
        }
        return lengest;
        
    }
};
```

### 131.Palindrome Partitioning

Given a string *s*, partition *s* such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of *s*.

**Example:**

```
Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
```

#### 解析

采用DFS。既然题目要求找到所有可能拆分成回文数的情况，那么肯定是所有的情况都要遍历到，对于每一个子字符串都要分别判断一次是不是回文数，那么肯定有一个判断回文数的子函数，还需要一个DFS函数用来递归，再加上原本的这个函数，总共需要三个函数来求解。

#### 代码

```c++
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string>> res;
        vector<string> path;
        DFS(s,res,path,0);
        return res;
    }
    
    void DFS(string& s,vector<vector<string>>& res, vector<string>& path,unsigned int start)
    {
        if(start == s.size())
        {
            res.push_back(path);
            return;
        }
        for(unsigned int i = start;i<s.size();++i)
        {
            if(isPalindrome(s,start,i))
            {
                path.push_back(s.substr(start,i-start+1));
                DFS(s,res,path,i+1);
                path.pop_back();
            }
        }
    }
    bool isPalindrome(string &s, unsigned int start,unsigned int end)
    {
        while(start<end&&s[start]==s[end])
        {
            start++;
            end--;
        }
        return start>=end;
    }
};
```

### 136.Single Number

Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.

**Note:**

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**Example 1:**

```
Input: [2,2,1]
Output: 1


```

**Example 2:**

```
Input: [4,1,2,1,2]
Output: 4
```

#### 解析

异或即可.

#### 代码

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size()<=0)
            return -1;
        int res=0;
        for(int i=0;i<nums.size();i++){
            res^=nums[i];
        }
        return res;
    }
};
```

### 138.Copy List with Random Pointer

A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.

Return a deep copy of the list.

#### 解析

和《剑指offer》[复杂链表的复制](https://github.com/starFalll/Sword-pointing-to-offer#25%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6) 是一样的题。

最简单的解法很显然需要额外的空间，这个额外的空间是由 `hash table` 的维护造成的。因为当我们访问一个结点时可能它的 random 指针指向的结点还没有访问过，结点还没有创建，所以需要用 `hash table` 的额外线性空间维护。

但我们可以通过链表原来结构中的 `next` 指针来替代 `hash table` 做哈希。假设有如下链表：

```
|------------|
|            v
1  --> 2 --> 3 --> 4


```

节点1的 random 指向了3。首先我们可以通过 next 遍历链表，依次拷贝主节点，并将其添加到原节点后面，如下：

```
1  --> 1' --> 2 --> 2' --> 3 --> 3' --> 4 --> 4'

```

调整新的节点的 random 指针，对于上面例子来说，我们需要将1'的 random 指向3'，其实也就是原先 random 指针的next节点。

```
|--------------------------|
|                          v
1  --> 1' --> 2 --> 2' --> 3 --> 3' --> 4 --> 4'
       |                         ^
       |-------------------------|


```

最后，拆分链表，就可以得到深度拷贝的链表了。

总结起来，实际我们对链表进行了三次扫描，第一次扫描对每个结点进行复制，然后把复制出来的新节点接在原结点的 next 指针上，也就是让链表变成一个重复链表，就是新旧更替；第二次扫描中我们把旧结点的随机指针赋给新节点的随机指针，因为新结点都跟在旧结点的下一个，所以赋值比较简单，就是 `node->next->random = node->random->next`，其中 `node->next` 就是新结点，因为第一次扫描我们就是把新结点接在旧结点后面。现在我们把结点的随机指针都接好了，最后一次扫描我们把链表拆成两个，第一个还原原链表，而第二个就是我们要求的复制链表。因为现在链表是旧新更替，只要把每隔两个结点分别相连，对链表进行分割即可。

#### 代码

```cpp
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if(!head) return nullptr;
        for(RandomListNode* cur=head;cur!=nullptr;){
            RandomListNode* node=new RandomListNode(cur->label);
            node->next=cur->next;
            cur->next=node;
            cur=node->next;
        }
        for(RandomListNode* cur=head;cur!=nullptr;){
            if(cur->random)
                cur->next->random=cur->random->next;
            cur=cur->next->next;
        }
        RandomListNode* new_head=head->next;
        RandomListNode* res=new_head;
        RandomListNode* cur=head;
        while(cur){
            cur->next=new_head->next;
            cur=cur->next;
            if(cur){
                new_head->next=cur->next;    
            }
            new_head=new_head->next;
        }
        return res;
        
    }
};
```

### 139.Word Break

Given a **non-empty** string *s* and a dictionary *wordDict* containing a list of **non-empty** words, determine if *s* can be segmented into a space-separated sequence of one or more dictionary words.

**Note:**

- The same word in the dictionary may be reused multiple times in the segmentation.
- You may assume the dictionary does not contain duplicate words.

**Example 1:**

```
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
```

**Example 2:**

```
Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
```

**Example 3:**

```
Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
```

#### 解析

// unbounded knapsack
// dp[j] [1, j] of s can be segmented into a space-separated sequence
// dp[j] = true if dp[j - wordDict[i].size()] && s.substr(j - wordDict[i].size(), wordDict[i].size()) == wordDict[i]
// dp[0] = True
// i from 0 to wordDict.size()-1, j from wordDict[i].size() to s.size()

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        if(s.empty()||wordDict.empty()) return false;
        vector<bool> dp(s.size()+1,false);
        dp[0]=true;
        for(int i=1;i<=s.size();++i)
        {
            for(int j=0;j<i;++j)
            {
                if(dp[j]&&find(wordDict.begin(), wordDict.end(), s.substr(j,i-j))!=wordDict.end())
                {
                    dp[i]=true;
                }
            }
        }
        return dp[s.size()];
    }
};
```
### 141.Linked List Cycle

Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

#### 解析

如果一个指针走一步，一个指针走两步，两个指针开始指向的结点不同，若干步以后两个指针指向同一个结点，说明存在循环。遇到有任意一个指针指向nullptr说明不存在循环。

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head) return false;
        ListNode* p1=head;
        ListNode* p2=head->next;
        while(p2&&p2->next&&p2->next->next&&p1){
            if(p1==p2)
                return true;
            p1=p1->next;
            p2=p2->next->next;
        }
        return false;
    }
};
```

### 142.Linked List Cycle II

Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.

**Note:** Do not modify the linked list.

**Follow up**:
Can you solve it without using extra space?

#### 解析

和《剑指offer》[链表中环的入口结点](https://github.com/starFalll/Sword-pointing-to-offer#55%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9) 是一样的题。

找是否成环可以看 141.Linked List Cycle 题。找到环以后绕环一圈即为环的大小n。

然后又是两个指针指向头结点，第一个指针先走n步，然后两个指针一起走，相遇即是入口结点。

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        int n=0;
        if(hasCycle(head,n)==false) return nullptr;
        ListNode* p1=head;
        ListNode* p2=p1;
        for(int i=0;i<n;i++){
            p2=p2->next;
        }
        while(p1!=p2){
            p1=p1->next;
            p2=p2->next;
        }
        return p1;
    }
    
    bool hasCycle(ListNode *head,int& n) {
        if(!head) return false;
        ListNode* p1=head;
        ListNode* p2=head->next;
        while(p2&&p2->next&&p2->next->next&&p1){
            if(p1==p2){
                n=1;
                while(p2->next!=p1){
                    n++;
                    p2=p2->next;
                }
                return true;
            }
            p1=p1->next;
            p2=p2->next->next;
        }
        return false;
    }
};
```



### 146.LRU Cache

Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.

`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
`put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

**Follow up:**
Could you do both operations in **O(1)** time complexity?

**Example:**

```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

#### 解析

为了使查找、插入和删除都有较高的性能，这题的关键是要使用一个双向链表和一个HashMap，因为：

- HashMap保存每个节点的地址，可以基本保证在`O(1)`时间内查找节点
- 双向链表能后在`O(1)`时间内添加和删除节点，单链表则不行

具体实现细节：

- 越靠近链表头部，表示节点上次访问距离现在时间最短，尾部的节点表示最近访问最少
- 访问节点时，如果节点存在，把该节点交换到链表头部，同时更新hash表中该节点的地址
- 插入节点时，如果cache的size达到了上限capacity，则删除尾部节点，同时要在hash表中删除对应的项；新节点插入链表头部

C++的`std::list` 就是个双向链表，且它有个 `splice()`方法，`O(1)`时间，非常好用。

#### 代码

```cpp
class LRUCache {
private:
    struct CacheNode{
        int key;
        int value;
        CacheNode(int k,int v):key(k),value(v){}
    };
    list<CacheNode> cacheList;
    unordered_map<int,list<CacheNode>::iterator> cacheMap;
    int _capacity;
public:
    LRUCache(int capacity) {
        this->_capacity=capacity;
    }
    
    int get(int key) {
        if(cacheMap.find(key)==cacheMap.end()) return -1;
        //put node to list head and update map
        cacheList.splice(cacheList.begin(),cacheList,cacheMap[key]);
        cacheMap[key]=cacheList.begin();
        return cacheMap[key]->value;
    }
    
    void put(int key, int value) {
        if(cacheMap.find(key)==cacheMap.end()){
            if(cacheList.size()==_capacity){
                cacheMap.erase(cacheList.back().key);
                cacheList.pop_back();
            }
            cacheList.push_front(CacheNode(key,value));
            cacheMap[key]=cacheList.begin();
        }
        else{
            cacheMap[key]->value=value;
            cacheList.splice(cacheList.begin(),cacheList,cacheMap[key]);
            cacheMap[key]=cacheList.begin();
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### 148.Sort List

Sort a linked list in *O*(*n* log *n*) time using constant space complexity.

**Example 1:**

```
Input: 4->2->1->3
Output: 1->2->3->4


```

**Example 2:**

```
Input: -1->5->3->4->0
Output: -1->0->3->4->5
```

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
private:
    ListNode* merge2Lists(ListNode* l1,ListNode* l2)
    {
        ListNode dummy(-1);
        ListNode* p= &dummy;
        while(l1&&l2){
            if(l1->val>l2->val){
                p->next=l2;
                l2=l2->next;
            }
            else{
                p->next=l1;
                l1=l1->next;
            }
            p=p->next;
        }
        if(l1){
            p->next=l1;
        }else if(l2){
            p->next=l2;
        }
        return dummy.next;
    }
public:
    ListNode* sortList(ListNode* head) {
        if(!head||!head->next) return head;
        /*
        step 1: split list into two parts
        */
        ListNode* fast=head,*slow=head;
        while(fast->next&&fast->next->next){//find mid node(slow)
            fast=fast->next->next;
            slow=slow->next;
        }
        fast=slow;
        slow=slow->next;
        fast->next=nullptr;
        /*
        step 2: sort each part l1 and l2
        */
        ListNode* l=sortList(head);
        ListNode* r=sortList(slow);
        /*
        step 3: merge step
        */
        return merge2Lists(l,r);
        
    }
    
};
```

### 152.Maximum Product Subarray

Given an integer array `nums`, find the contiguous subarray within an array (containing at least one number) which has the largest product.

**Example 1:**

```
Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.

```

**Example 2:**

```
Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

#### 解析

维持一个最大值和最小值，遇到负值就交换最大和最小值的位置（因为最大值乘以负数会变成最小值，最小值反之），更新最大值和最小值。

#### 代码

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int res = nums[0];
        for(int i=1, imax = res, imin=res; i < nums.size();++i)
        {
            if(nums[i]<0)
                swap(imax,imin);
            //当前值可能大于之前的最大值×当前值
            imax = max(nums[i], imax*nums[i]);
            imin = min(nums[i], imin*nums[i]);
            res = max(res, imax);
        }
        return res;
    }
};
```

### 153.Find Minimum in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  `[0,1,2,4,5,6,7]` might become  `[4,5,6,7,0,1,2]`).

Find the minimum element.

You may assume no duplicate exists in the array.

**Example 1:**

```
Input: [3,4,5,1,2] 
Output: 1
```

**Example 2:**

```
Input: [4,5,6,7,0,1,2]
Output: 0
```

#### 代码

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.empty()) return -1;
        int left = 0;
        int right = nums.size()-1;
        while(left<right)
        {
            int mid = left + (right-left)/2;
            if(nums[mid]>=nums[right])
            {
                left = mid+1;
            }
            else if(nums[mid]<nums[right])
            {
                right = mid;
            }
        }
        return nums[left];
    }
};
```

### 155.Min Stack

Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

- push(x) -- Push element x onto stack.
- pop() -- Removes the element on top of the stack.
- top() -- Get the top element.
- getMin() -- Retrieve the minimum element in the stack.

 

**Example:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.

```

#### 解析

两个栈，长度维持一样，第一个栈放实际数值，第二个栈放对应位置的最大值。

#### 代码

```c++
class MinStack {
private:
    stack<int> s1;
    stack<int> s2;
public:
    /** initialize your data structure here. */
    MinStack() {
        
    }
    
    void push(int x) {
        if(s1.empty()&&s2.empty()){
            s1.push(x);s2.push(x);
        }
        else{
            s1.push(x);
            if(x < s2.top()) s2.push(x);
            else s2.push(s2.top());
        }
    }
    
    void pop() {
        s1.pop();
        s2.pop();
    }
    
    int top() {
        return s1.top();
    }
    
    int getMin() {
        return s2.top();
    }
};
```

### 160.Intersection of Two Linked Lists

Write a program to find the node at which the intersection of two singly linked lists begins.

#### 解析

两链表找公共结点

#### 代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA||!headB) return nullptr;
        int lenA=0,lenB=0;
        ListNode* ha = headA;
        ListNode* hb = headB;
        while(ha)
        {
            lenA++;
            ha=ha->next;
        }
        while(hb)
        {
            lenB++;
            hb=hb->next;
        }
        int n = 0;
        ListNode* head=nullptr;
        ListNode* oldHead = nullptr;
        if(lenA>lenB)
        {
            n=lenA-lenB;
            head = headA;
            oldHead = headB;
        }
        else
        {
            n=lenB-lenA;
            head = headB;
            oldHead = headA;
        }
        while(n>0&&head)
        {
            head=head->next;
            n--;
        }
        while(head&&oldHead&&head!=oldHead)
        {
            head=head->next;
            oldHead=oldHead->next;
        }
        return head;
        
    }
};
```

### 169.Majority Element

Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Example 1:**

```
Input: [3,2,3]
Output: 3
```

**Example 2:**

```
Input: [2,2,1,1,1,2,2]
Output: 2
```

#### 解析

剑指offer原题

#### 代码

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        if(nums.empty()) return -1;
        int res = nums[0];
        int count = 1;
        for(int i=1;i<nums.size();++i)
        {
            if(nums[i]!=res)
            {
                count--;
                if(count==0) 
                {
                    res = nums[i];
                    count = 1;
                }
            }
            else
            {
                count++;
            }
        }
        return res;
    }
};
```

### 189.Rotate Array

Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.

**Example 1:**

```
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

```

**Example 2:**

```
Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]

```

**Note:**

- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
- Could you do it in-place with O(1) extra space?

#### 代码

```c++
class Solution {
private:
    void reverse(vector<int>& nums, int begin,int end)
    {
        if(begin>=end) return;
        while(begin<end)
        {
            swap(nums[begin],nums[end]);
            begin++;
            end--;
        }
    }
public:
    void rotate(vector<int>& nums, int k) {
        k=k%(nums.size());
        if(k<=0) return;
        reverse(nums, 0, nums.size()-1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size()-1);
    }
};
```

### 198.House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
```

#### 解析

// dp[i] the maximum amount of money you can rob of nums[0, j]
// dp[i] = max(dp[i-1], dp[i-2] + nums[i]) // not rob i or rob i
// dp[0] = nums[0], dp[1] = max(nums[0], nums[1])
// i is [2, nums.size())

#### 代码

```c++
class Solution {
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
        }
        return dp.back();
    }
};
```
### 200.Number of Islands

Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input:
11110
11010
11000
00000

Output: 1

```

**Example 2:**

```
Input:
11000
11000
00100
00011

Output: 3
```

#### 解析

DFS，遍历所有相连的'1'，每次能遍历则结果加一（grid全为1表示一个岛）。

#### 代码

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty()||grid[0].empty()) return 0;
        vector<vector<int>> visited(grid.size(),vector<int>(grid[0].size(),0));
        int res = 0;
        for(int i=0;i<grid.size();++i)
        {
            for(int j=0;j<grid[i].size();++j)
            {
                if(visited[i][j]!=0) continue;
                if(grid[i][j]=='1') 
                {
                    res++;
                    DFS(grid,visited,i,j);
                }
            }
        }
        return res;
    }
    void DFS(vector<vector<char>>& grid, vector<vector<int>>& visited, int row, int col)
    {
        if(row<0||row>=grid.size()||col<0||col>=grid[row].size()||visited[row][col]==1||grid[row][col]=='0')
            return;
        visited[row][col] = 1;
        DFS(grid,visited,row+1,col);
        DFS(grid,visited,row,col+1);
        DFS(grid,visited,row-1,col);
        DFS(grid,visited,row,col-1);
    }
};
```

### 206.Reverse Linked List

Reverse a singly linked list.

**Example:**

```
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL

```

**Follow up:**

A linked list can be reversed either iteratively or recursively. Could you implement both?

#### 代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* f=nullptr;
        ListNode* s=head;
        ListNode* t=s;
        while(s&&t){
            t=t->next;
            s->next=f;
            f=s;
            s=t;
        }
        return f;
    }
};
```

### 207.Course Schedule

There are a total of *n* courses you have to take, labeled from `0` to `n-1`.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`

Given the total number of courses and a list of prerequisite **pairs**, is it possible for you to finish all courses?

**Example 1:**

```
Input: 2, [[1,0]] 
Output: true
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0. So it is possible.
```

**Example 2:**

```
Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take. 
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.
```

**Note:**

1. The input prerequisites is a graph represented by **a list of edges**, not adjacency matrices. Read more about [how a graph is represented](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs).
2. You may assume that there are no duplicate edges in the input prerequisites.

#### 解析

拓扑排序。

#### 代码

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> graph = GetGraph(numCourses, prerequisites);
        vector<int> InDegree(numCourses);
        GetInDegree(InDegree, graph);
        for(int i=0;i<numCourses;++i)
        {
            int j = 0;
            for(;j<numCourses;++j)
            {
                if(!InDegree[j]) break;
            }
            if(j==numCourses) return false;
            InDegree[j]=-1;
            for(auto m:graph[j])//将以j结点为入度的结点的入度减一
            {
                InDegree[m]--;
            }
        }
        return true;
    }
    
    vector<vector<int>> GetGraph(int numCourses, vector<vector<int>>& prerequisites)
    {
        vector<vector<int>> graph(numCourses);//graph[i] 代表第i个结点的所有出度结点
        for(int i=0;i<prerequisites.size();++i)
        {
            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);
        }
        return graph;
    }
    void GetInDegree(vector<int>& InDegree, vector<vector<int>>& graph)
    {
        for(int i=0;i<graph.size();++i)
        {
            for(int j=0;j<graph[i].size();++j)
            {
                InDegree[graph[i][j]]++;//InDegree[i]为第i个结点的入度
            }
        }
    }
};
```

### 208.Implement Trie (Prefix Tree)

Implement a trie with `insert`, `search`, and `startsWith` methods.

**Example:**

```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");   
trie.search("app");     // returns true
```

**Note:**

- You may assume that all inputs are consist of lowercase letters `a-z`.
- All inputs are guaranteed to be non-empty strings.

#### 解析

前缀树，每一个结点为26个字母。

#### 代码

```c++
struct TrieNode
{
    TrieNode  *node[26];
    bool is_word;
    TrieNode(bool word = false)
    {
        memset(node, 0, sizeof(node));
        is_word = word;
    }
};

class Trie {
private:
    TrieNode* root;
public:
    /** Initialize your data structure here. */
    Trie() {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        TrieNode* p = root;
        for(int i=0;i<word.size();++i)
        {
            if(p->node[word[i]-'a']==NULL)
                p->node[word[i]-'a'] = new TrieNode();
            p = p->node[word[i]-'a'];
        }
        p->is_word = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        TrieNode* p = find(word);
        return (p != NULL && p->is_word);
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        TrieNode* p = find(prefix);
        return p != NULL;
    }
    TrieNode* find(string s)
    {
        TrieNode* p = root;
        for(int i=0;i<s.size()&&p;++i)
        {
            p = p->node[s[i]-'a'];
        }
        return p;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

### 215.Kth Largest Element in an Array

Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

**Example 1:**

```
Input: [3,2,1,5,6,4] and k = 2
Output: 5

```

**Example 2:**

```
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
```

**Note: **
You may assume k is always valid, 1 ≤ k ≤ array's length.

#### 解析

Method1: 快排不排完。O(n), TLE in newest Leetcode Test case.

Method2: Three way partition.

#### 代码

```c++
class Solution {
private:
    int partition(vector<int>& nums, int left, int right) {
        if (left >= right) return left;
        int pivot = left + (right - left) / 2;
        swap(nums[pivot], nums[right]);
        int index = left;
        while (left < right) {
            if (nums[left] > nums[right]) {
                swap(nums[left], nums[index++]);
            }
            left++;
        }
        swap(nums[right], nums[index]);
        return index;
    }
public:
    int findKthLargest(vector<int>& nums, int k) {
        if (nums.empty() || k > nums.size()) return 0;
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int index = partition(nums, left, right);
            if (index == k - 1) return nums[index];
            else if (index < k - 1) {
                left = index + 1;
            }
            else {
                right = index - 1;
            }
        }
        return nums[left];
        
    }
};


// method2
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        return quickselect(nums, 0, n - 1, n - k);
    }
private:
    // Return the kth smallest element in [left, right]
    int quickselect(vector<int>& nums, int left, int right, int k) {
        if (left == right) {
            return nums[left];
        }

        auto pivotIndex = left + (rand() % (right - left + 1));
        auto [firstEqual, firstGreater] = threeWayPartition(nums, left, right, nums[pivotIndex]);
        if (k < firstEqual) {
            return quickselect(nums, left, firstEqual - 1, k);
        }
        if (k >= firstEqual && k < firstGreater) {
            return nums[k];
        }
        return quickselect(nums, firstGreater, right, k);
    }

    pair<int, int> threeWayPartition(vector<int>& nums, int left, int right, int pivot) {
        // left <= i <= j <= k <= right
        // [left, i) are values less than pivot
        // [i, j) are values equal to pivot
        // [j, k] are values not yet sorted
        // [k+1, right] are values greater than pivot
        int i = left, j = left, k = right;
        while (j <= k) {
            if (nums[j] < pivot) {
                swap(nums[i], nums[j]);
                i++;
                j++;
            } else if (nums[j] == pivot) {
                j++;
            } else {
                swap(nums[k], nums[j]);
                k--;
            }
        }
        return {i, j};
    }
};
```

### 226.Invert Binary Tree

Invert a binary tree.

**Example:**

Input:

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

Output:

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

#### 代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

### [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)

Given the `root` of a binary search tree, and an integer `k`, return *the* `kth` *smallest value (**1-indexed**) of all the values of the nodes in the tree*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
Input: root = [3,1,4,null,2], k = 1
Output: 1
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
```

 

**Constraints:**

- The number of nodes in the tree is `n`.
- `1 <= k <= n <= 104`
- `0 <= Node.val <= 104`

 

**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?

#### Solution

In-order Traversal

Time complexity:O(n)

#### Code

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int size = 0;
    int getRes(TreeNode* root, int k) {
        if (!root) return -1;
        int len1 = 0, len2 = 0;
        int left = getRes(root->left, k);
        if (left > -1) return left;
        size++;
        if (k == size) return root->val;
        int right = getRes(root->right, k);
        if (right > -1) return right;
        return -1;
    }
    int kthSmallest(TreeNode* root, int k) {
        size = 0;
        return getRes(root, k);
    }
};
```



### 234.Palindrome Linked List

Given a singly linked list, determine if it is a palindrome.

**Example 1:**

```
Input: 1->2
Output: false
```

**Example 2:**

```
Input: 1->2->2->1
Output: true
```

**Follow up:**
Could you do it in O(n) time and O(1) space?

#### 解析

要保证O(1)的空间复杂度，可以将链表分成两半，后半部分翻转，再从头开始逐一比较。

#### 代码

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head||!head->next) return true;
        int len=0;
        for(ListNode* node = head;node;node=node->next) len++;
        int mid = len/2;
        ListNode* mnode = head;
        for(int i=1;i<mid&&mnode;++i)mnode=mnode->next;
        ListNode* nextnode = head;
        if(len&0x01) nextnode=mnode->next->next;
        else nextnode=mnode->next;
        ListNode* lastnode = nextnode;
        nextnode = Reverse(nextnode);
        ListNode* nd1 = head;
        ListNode* nd2 = nextnode;
        for(;nd1!=mnode->next&&nd2!=lastnode->next;nd1=nd1->next,nd2=nd2->next)
        {
            if(nd1->val!=nd2->val) return false;
        }
        if(nd1==mnode->next&&nd2==lastnode->next)
        {
            return true;
        }
        return false;
    }
    ListNode* Reverse(ListNode* head)
    {
        if(!head||!head->next) return head;
        ListNode* prev = head;
        ListNode* cur = head->next;
        ListNode* next = head->next;
        head->next = NULL;
        while(cur)
        {
            next = cur->next;
            cur->next = prev;
            prev = cur;
            cur = next;
            
        }
        return prev;
    }
};
```

### 236.Lowest Common Ancestor of a Binary Tree

​	Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow **a node to be a descendant of itself**).”

Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

**Example 1:**

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

**Example 2:**

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

 

**Note:**

- All of the nodes' values will be unique.
- p and q are different and both values will exist in the binary tree.

#### 解析

注意，若p和q中有一个为父节点，则一定是从上到下先遍历到的。

#### 代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //该函数有父节点则返回父节点，否则返回匹配到的p或者q
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root) return nullptr;
        if(root==p||root==q) return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        //说明两边均有匹配的节点
        if(left&&right)
        {
            return root;
        }
        //否则返回不为空的结点
        return left?left:right;
    }
};
```

### 238.Product of Array Except Self

Given an array `nums` of *n* integers where *n* > 1,  return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

**Example:**

```
Input:  [1,2,3,4]
Output: [24,12,8,6]
```

**Note:** Please solve it **without division** and in O(*n*).

**Follow up:**
Could you solve it with constant space complexity? (The output array **does not** count as extra space for the purpose of space complexity analysis.)

#### 解析

用一个整数 head 存储数组当前下标之前的数的乘积, tail 存储数组当前下标之后的数的乘积, 则 head \* tail 便是当前下标所对应的 output.

#### 代码

```c++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        if(n <= 1){
            return nums;
        }
        vector<int> res(n, 1);
        int head = 1, tail = 1;
        
        for(int i = 0; i < n; i++){
            res[i] *= head;
            head *= nums[i];
            res[n-i-1] *= tail;
            tail *= nums[n-i-1];
        }
        
        return res;
    }
};
```

### [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)

You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return *the max sliding window*.

 

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

#### Solution

Slide windows + Decreasing stack(deque).

#### Code

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        deque<int> s;
        vector<int> res;
        for (int i = 0; i < k && i < n; i++) {
            while (!s.empty() && nums[s.back()] <= nums[i]) {
                s.pop_back();
            }
            s.push_back(i);
        }
        res.push_back(nums[s.front()]);
        if (n <= k) return res;
        int i = k;
        while (i < n) {
            if (i-s.front() >= k) {
                s.pop_front();
            }
            while (!s.empty() && nums[s.back()] <= nums[i]) {
                s.pop_back();
            }
            s.push_back(i);
            res.push_back(nums[s.front()]);
            i++;
        }
        return res;
    }
};
```



### 240.Search a 2D Matrix II

Write an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:

- Integers in each row are sorted in ascending from left to right.
- Integers in each column are sorted in ascending from top to bottom.

**Example:**

Consider the following matrix:

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

Given target = `5`, return `true`.

Given target = `20`, return `false`.

#### 解析

剑指offer原题

#### 代码

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.size() <=0 || matrix[0].size() <= 0 ){
            return false;
        }
        int row = matrix.size();
        int col = matrix[0].size();
        
        for(int i = 0, j = col - 1; i < row && j >= 0;){
            if(matrix[i][j] > target){
                j--;
            }else if(matrix[i][j] < target){
                i++;
            }else{
                return true;
            }
        }
        return false;
    }
};
```

### 283.Move Zeroes

Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Example:**

```
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
```

**Note**:

1. You must do this **in-place** without making a copy of the array.
2. Minimize the total number of operations.

#### 代码

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size();
        if(n <= 1) return;
        int pZero = 0;
        int pNotZero = 0;
        while(pNotZero < n){
            if(nums[pNotZero] != 0) {
                if(pNotZero > pZero){
                    swap(nums[pNotZero], nums[pZero]);
                }
                pNotZero++;
                pZero++;
            }else{
                pNotZero++;
            }
            
        }
        return;
    }
};
```

### 287.Find the Duplicate Number

Given an array *nums* containing *n* + 1 integers where each integer is between 1 and *n* (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

**Example 1:**

```
Input: [1,3,4,2,2]
Output: 2
```

**Example 2:**

```
Input: [3,1,3,4,2]
Output: 3
```

**Note:**

1. You **must not** modify the array (assume the array is read only).
2. You must use only constant, *O*(1) extra space.
3. Your runtime complexity should be less than *O*(*n*2).
4. There is only one duplicate number in the array, but it could be repeated more than once.

#### 解析

二分查找.

#### 代码

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int n = nums.size()-1;
        int low = 0, high = n;
        int mid, count;
        while(low < high) {
            mid = (high - low) / 2 + low;
            count = 0;
            for(int num : nums){
                if(num<=mid) count++;
            }
            if(count > mid) high = mid;
            else low = mid+1;
        }
        return low;
    }
};
```

### [295. Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.

- For example, for `arr = [2,3,4]`, the median is `3`.
- For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.

Implement the MedianFinder class:

- `MedianFinder()` initializes the `MedianFinder` object.
- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.
- `double findMedian()` returns the median of all elements so far. Answers within `10-5` of the actual answer will be accepted.

 

**Example 1:**

```
Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

 

**Constraints:**

- `-105 <= num <= 105`
- There will be at least one element in the data structure before calling `findMedian`.
- At most `5 * 104` calls will be made to `addNum` and `findMedian`.

#### 解析

Constraints is `-10^5 <= num <= 10^5`, so consider each call cost logN time complexity.

Using two heaps, one's top is biggest one, another's top is smallest one. The first heap is always equal or more than one values to second heap. When the value is not fit situation, pop value from some heap and push back new value.

#### 代码

```c++
class MedianFinder {
private:
    priority_queue<int, vector<int>, greater<int>> mx;
    priority_queue<int> mi;
public:
    MedianFinder() {
    }
    
    void addNum(int num) {
        if (mi.size() == mx.size()+1) {
            if (num >= mi.top()) {
                mx.push(num);
            }
            else {
                int tmp = mi.top();
                mi.pop();
                mx.push(tmp);
                mi.push(num);
            }
        }
        else {
            if (mx.empty() || num <= mx.top()) {
                mi.push(num);
            }
            else {
                int tmp = mx.top();
                mx.pop();
                mx.push(num);
                mi.push(tmp);
            }
        }
    }
    
    double findMedian() {
        if (mi.size() == mx.size() + 1) return mi.top();
        return (double)(mi.top()+mx.top()) / 2;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```
### 300.Longest Increasing Subsequence

Given an unsorted array of integers, find the length of longest increasing subsequence.

**Example:**

```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```

**Note:**

- There may be more than one LIS combination, it is only necessary for you to return the length.
- Your algorithm should run in O(*n2*) complexity.

**Follow up:** Could you improve it to O(*n* log *n*) time complexity?

#### 解析

最长递增子序列，最简单的方法可以用动归来做，**dp[i]**表示以下标i结尾的序列的LIS大小。

#### 代码

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size()<=0) return 0;
        vector<int> dp(nums.size(),1);
        int maxlen=1;
        for(int j=0;j<nums.size();++j)
        {
            for(int i=0;i<j;++i)
            {
                if(nums[i]<nums[j])
                {
                    dp[j]=max(dp[i]+1,dp[j]);
                    maxlen = max(maxlen, dp[j]);
                }
            }
        }
        return maxlen;
    }
};
```

### 322.Coin Change

You are given coins of different denominations and a total amount of money *amount*. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.

**Example 1:**

```
Input: coins = [1, 2, 5], amount = 11
Output: 3 
Explanation: 11 = 5 + 5 + 1
```

**Example 2:**

```
Input: coins = [2], amount = 3
Output: -1
```

#### 解析

// unbounded knapsack

// dp[j] the fewest number of coins that you need to make up j
// dp[j] = min(dp[j], dp[j-coins[i]] + 1)
// dp[0] = 0 (zero number)

#### 代码

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int MAX = amount + 1;
        vector<int> dp(amount + 1, MAX);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++) {
            for(int j=0; j< coins.size();j++) {
                if(coins[j] <= i)
                    dp[i] = min(dp[i], dp[i- coins[j]]+1);
            }
        }
        return dp[amount] > amount ? -1: dp[amount];
    }
};
```
### [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

Given an integer array `nums` and an integer `k`, return *the* `k` *most frequent elements*. You may return the answer in **any order**.

 

**Example 1:**

```
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `k` is in the range `[1, the number of unique elements in the array]`.
- It is **guaranteed** that the answer is **unique**.

 

**Follow up:** Your algorithm's time complexity must be better than `O(n log n)`, where n is the array's size.

#### Solution

Hashmap+priority_queue

Time complexity: O(nlogk)

#### Code

```c++
class MyComp {
public:
    bool operator()(const pair<int, int>& left, const pair<int, int>& right) {
        return left.second > right.second;
    };
};
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> tables;
        for (const auto& num : nums) {
            tables[num]++;
        }
        priority_queue<pair<int, int>, vector<pair<int, int>>, MyComp> pri_que;
        for (const auto& item : tables) {
            pri_que.push(item);
            while (pri_que.size() > k) {
                pri_que.pop();
            }
        }
        vector<int> res;
        while (!pri_que.empty()) {
            auto& item = pri_que.top();
            res.push_back(item.first);
            pri_que.pop();
        }
        return res;

    }
};
```



### [394. Decode String](https://leetcode.com/problems/decode-string/)

Given an encoded string, return its decoded string.

The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.

You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.

The test cases are generated so that the length of the output will never exceed `105`.

 

**Example 1:**

```
Input: s = "3[a]2[bc]"
Output: "aaabcbc"
```

**Example 2:**

```
Input: s = "3[a2[c]]"
Output: "accaccacc"
```

**Example 3:**

```
Input: s = "2[abc]3[cd]ef"
Output: "abcabccdcdcdef"
```

 

**Constraints:**

- `1 <= s.length <= 30`
- `s` consists of lowercase English letters, digits, and square brackets `'[]'`.
- `s` is guaranteed to be **a valid** input.
- All the integers in `s` are in the range `[1, 300]`.

#### Solution

字符串嵌套处理模版。

与[1096. Brace Expansion II](https://leetcode.com/problems/brace-expansion-ii/)类似

#### Code

```c++
class Solution {
public:
    string decodeString(string s) {
        int pos = s.rfind('[');
        if (pos == string::npos) return s;
        int l = pos-1;
        while (l >= 0 && s[l] >= '0' && s[l] <= '9') {
            l--;
        }
        string left = s.substr(0, l+1);
        int digit = stoi(s.substr(l+1, pos - l));
        pos++;
        l = pos;
        while(l < s.size() && s[l] != ']') l++;
        string mid = s.substr(pos, l-pos);
        string right = s.substr(l+1);
        string new_mid;
        for (int i = 1; i <= digit; i++) {
            new_mid += mid;
        }
        return decodeString(left+new_mid+right);
    }
};
```



### [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

Given an integer array `nums`, return `true` *if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or* `false` *otherwise*.

 

**Example 1:**

```
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

**Example 2:**

```
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
```

 

**Constraints:**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

#### Solution

```cpp
// using 01 knapsack template
// the sum of all nums are t, the max cap of knapsack is t / 2
// dp[i] means the maximum weight of the backpack.
// dp[i] = max(dp[i], dp[i-nums[i]] + nums[i])
// dp[0] = 0
// i from 0 to nums.size() - 1, j from t/2 to 0 
```

#### Code

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (auto& num : nums) sum += num;
        if (sum & 1) return false;
        vector<int> dp(sum/2+1, 0);
        for (int i = 0; i < nums.size(); i++) {
            for (int j = sum/2; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);
            }
        }
        return dp.back() == sum/2;
    }
};
```



### [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

Given two strings `s` and `p`, return *an array of all the start indices of* `p`*'s anagrams in* `s`. You may return the answer in **any order**.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

**Example 1:**

```
Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
```

**Example 2:**

```
Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
```

 

**Constraints:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` and `p` consist of lowercase English letters.

#### Solution

slide windows, start means the start index of *anagrams*.

Time complexity: O(n)

#### Code

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.size() < p.size()) return {};
        vector<int> tables(26, 0);
        for (auto& ch : p) tables[ch-'a']++;
        vector<int> res;
        int start = 0;
        int len = p.size();
        int i = 0;
        while (i < s.size()) {
            if (tables[s[i]-'a'] > 0) {
                tables[s[i]-'a']--;
                len--;
                if (len == 0) {
                    res.push_back(start);
                    tables[s[start++]-'a']++;
                    len++;
                }
                i++;
            }
            else {
              // maybe cur value can form the result if tables[s[i]-'a'] can > 0
                while (start < i && tables[s[i]-'a'] <= 0) {
                    tables[s[start++]-'a']++;
                    len++;
                }
                if (tables[s[i]-'a'] <= 0) {
                    i++;
                    start = i;
                }
            }
        }
        return res;
    }
};
```



### [543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)

Given the `root` of a binary tree, return *the length of the **diameter** of the tree*.

The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

The **length** of a path between two nodes is represented by the number of edges between them.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
```

**Example 2:**

```
Input: root = [1,2]
Output: 1
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `-100 <= Node.val <= 100`

#### Solution

Post-order Traversal.

Time complexity: O(n)

#### Code

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root, int& ans) {
        if (!root) return 0;
        int left = 0, right = 0;
        if (root->left)
            left = 1+diameterOfBinaryTree(root->left, ans);
        if (root->right)
            right = 1+diameterOfBinaryTree(root->right, ans);
        if (ans < left+right) {
            ans = left+right;
        }
        return max(left, right);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        int ans = 0;
        int res = diameterOfBinaryTree(root, ans);
        return max(ans, res);
    }
};
```



### [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)

Given an array of integers `nums` and an integer `k`, return *the total number of subarrays whose sum equals to* `k`.

A subarray is a contiguous **non-empty** sequence of elements within an array.

 

**Example 1:**

```
Input: nums = [1,1,1], k = 2
Output: 2
```

**Example 2:**

```
Input: nums = [1,2,3], k = 3
Output: 2
```

 

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

#### 解析

`nums[i,...j] = nums[0...i] - nums[0...j] = k`

-> 所以如果`nums[0...i]-k`有结果，则说明`nums[i....j]==k`存在，用prefix sum处理，用hashmap存储前缀和。

先加res是为了解决k=0的情况，由于先加res，由于存在`sum==k`的情况，所以初始化需要插入`{0, 1}`

#### 代码

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> m;
        m.insert({0, 1});
        int sum = 0, res = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
          // 先加res是为了解决k=0的情况
            res += m[sum - k];
            m[sum]++;
        }
        return res;
    }
};
```
### 567.Permutation in String

Given two strings **s1** and **s2**, write a function to return true if **s2** contains the permutation of **s1**. In other words, one of the first string's permutations is the **substring** of the second string.

 

**Example 1:**

```
Input: s1 = "ab" s2 = "eidbaooo"
Output: True
Explanation: s2 contains one permutation of s1 ("ba").

```

**Example 2:**

```
Input:s1= "ab" s2 = "eidboaoo"
Output: False
```

#### 解析

用两个26位数组保存字符，滑动窗口（长度为s1长度）从左向右滑动。每次滑动以后比较两个数组内容是否一致。

#### 代码

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        vector<int> c1(26,0);
        vector<int> c2(26,0);
        int l1=s1.size();
        int l2=s2.size();
        for(int i=0;i<l1;++i)
            c1[s1[i]-'a']++;
        for(int i=0;i<l2;++i)
        {
            if(i>=l1)
            {
                c2[s2[i-l1]-'a']--;
            }
            c2[s2[i]-'a']++;
            if(c1==c2)
                return true;
        }
        return false;
    }
};

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if (s1.size() > s2.size()) return false;
        vector<int> tables(26, 0);
        int n1 = s1.size(), n2 = s2.size();
        for (auto& ch : s1) tables[ch-'a']++;
        int start = 0, end = 0;
        int len = n1;
        for (; end < n1; end++) {
            tables[s2[end]-'a']--;
            if (tables[s2[end]-'a'] >= 0) len--;
            if (len == 0) return true;
        }

        while (end < n2) {
            tables[s2[start]-'a']++;
            if (tables[s2[start]-'a'] > 0) len++;
            tables[s2[end]-'a']--;
            if (tables[s2[end]-'a'] >= 0) len--;
            if (len == 0) return true;
            end++;
            start++;
        }
        return false;

    }
};
```

### [704. Binary Search](https://leetcode.com/problems/binary-search/)

Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

You must write an algorithm with `O(log n)` runtime complexity.

 

**Example 1:**

```
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
```

**Example 2:**

```
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
```

 

**Constraints:**

- `1 <= nums.length <= 104`
- `-104 < nums[i], target < 104`
- All the integers in `nums` are **unique**.
- `nums` is sorted in ascending order.

#### Solution

Time complexity: O(logn)

#### Code

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int start = 0, end = nums.size()-1;
        while (start <= end) {
            int mid = start + (end-start)/2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] < target) {
                start = mid+1;
            }
            else {
                end = mid-1;
            }
        }
        return -1;
    }
};
```



### 739. Daily Temperatures

Given an array of integers `temperatures` represents the daily temperatures, return *an array* `answer` *such that* `answer[i]` *is the number of days you have to wait after the* `ith` *day to get a warmer temperature*. If there is no future day for which this is possible, keep `answer[i] == 0` instead.

**Example 1:**

```
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
```

**Example 2:**

```
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
```

**Constraints:**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

#### Solution

单调栈(monotonic stack).

monotonically decreasing stack.

什么时候用单调栈呢？

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。时间复杂度为O(n)。

#### Code

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n, 0);
        stack<pair<int, int>> s;
        s.push({temperatures[0], 0});
        for (int i = 1; i < n; i++) {
            while (!s.empty() && temperatures[i] > s.top().first) {
                res[s.top().second] = i - s.top().second;
                s.pop();
            }
            s.push({temperatures[i], i});
        }
        return res;
    }
};
```
### [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)

You are given an `m x n` `grid` where each cell can have one of three values:

- `0` representing an empty cell,
- `1` representing a fresh orange, or
- `2` representing a rotten orange.

Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.

Return *the minimum number of minutes that must elapse until no cell has a fresh orange*. If *this is impossible, return* `-1`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)

```
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
```

**Example 2:**

```
Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
```

**Example 3:**

```
Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.
```

 

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 10`
- `grid[i][j]` is `0`, `1`, or `2`.

#### Solution

BFS

Time Complexity: O(n)

#### Code

```c++
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q;
        int fresh = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) q.push({i, j});
                else if (grid[i][j] == 1) fresh++;
            }
        }
        if (fresh == 0) return 0;
        int time = 0;
        vector<int> next = {0, 1, 0, -1, 0};
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i < size; i++) {
                auto [row, col] = q.front();q.pop();
                for (int j = 0; j < 4; j++) {
                    int next_row = row + next[j];
                    int next_col = col + next[j+1];
                    if (next_row >= 0 && next_row < m && next_col >= 0 && next_col < n 
                        && grid[next_row][next_col] == 1) {
                            grid[next_row][next_col] = 2;
                            q.push({next_row, next_col});
                            fresh--;
                    }
                }
            }
            time++;
            if (fresh == 0) return time;
        }
        return -1;
    }
};
```



### 1143.Longest Common Subsequence

Given two strings `text1` and `text2`, return the length of their longest common subsequence.

A *subsequence* of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A *common subsequence* of two strings is a subsequence that is common to both strings.

 

If there is no common subsequence, return 0.

 

**Example 1:**

```
Input: text1 = "abcde", text2 = "ace" 
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
```

**Example 2:**

```
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
```

**Example 3:**

```
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
```

 

**Constraints:**

- `1 <= text1.length <= 1000`
- `1 <= text2.length <= 1000`
- The input strings consist of lowercase English characters only.

#### 解析

最长公共子序列。用dp求解。设dp\[i+1\]\[j+1\]为序列1第i+1位和序列2第j+1位之前的最长公共子序列。动态规划方程为：

```c++
dp[i][j] = 0 ,i==j
dp[i][j] = dp[i-1][j-1]+1 , s1[i]==s2[j]
dp[i][j] = max(dp[i][j-1],dp[i-1][j]), s1[i]!=s2[j]
```

#### 代码

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        if(text1.size()==0||text2.size()==0) return 0;
        vector<vector<int>> dp(text1.size()+1,vector<int>(text2.size()+1,0));
        for(int i=0;i<text1.size();++i)
        {
            for(int j=0;j<text2.size();++j)
            {
                if(text1[i]==text2[j])
                {
                    dp[i+1][j+1] = dp[i][j]+1;
                }
                else
                {
                    dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```

