### [381. Insert Delete GetRandom O(1) - Duplicates allowed](https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

`RandomizedCollection` is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.

Implement the `RandomizedCollection` class:

- `RandomizedCollection()` Initializes the empty `RandomizedCollection` object.
- `bool insert(int val)` Inserts an item `val` into the multiset, even if the item is already present. Returns `true` if the item is not present, `false` otherwise.
- `bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item is present, `false` otherwise. Note that if `val` has multiple occurrences in the multiset, we only remove one of them.
- `int getRandom()` Returns a random element from the current multiset of elements. The probability of each element being returned is **linearly related** to the number of the same values the multiset contains.

You must implement the functions of the class such that each function works on **average** `O(1)` time complexity.

**Note:** The test cases are generated such that `getRandom` will only be called if there is **at least one** item in the `RandomizedCollection`.

 

**Example 1:**

```
Input
["RandomizedCollection", "insert", "insert", "insert", "getRandom", "remove", "getRandom"]
[[], [1], [1], [2], [], [1], []]
Output
[null, true, false, true, 2, true, 1]

Explanation
RandomizedCollection randomizedCollection = new RandomizedCollection();
randomizedCollection.insert(1);   // return true since the collection does not contain 1.
                                  // Inserts 1 into the collection.
randomizedCollection.insert(1);   // return false since the collection contains 1.
                                  // Inserts another 1 into the collection. Collection now contains [1,1].
randomizedCollection.insert(2);   // return true since the collection does not contain 2.
                                  // Inserts 2 into the collection. Collection now contains [1,1,2].
randomizedCollection.getRandom(); // getRandom should:
                                  // - return 1 with probability 2/3, or
                                  // - return 2 with probability 1/3.
randomizedCollection.remove(1);   // return true since the collection contains 1.
                                  // Removes 1 from the collection. Collection now contains [1,2].
randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.
```

 

**Constraints:**

- `-231 <= val <= 231 - 1`
- At most `2 * 105` calls **in total** will be made to `insert`, `remove`, and `getRandom`.
- There will be **at least one** element in the data structure when `getRandom` is called.

#### Solution

There are two data member in the solution

1. a vector **nums**
2. an unordered_map **m**

The **key** of **m** is the **val**, the **value** of **m** is a vector contains indices where the **val** appears in **nums**.
Each element of **nums** is a pair, the first element of the pair is **val** itself, the second element of the pair is an index into **m[val]**.
There is a relationship between **nums** and **m**:

`m[nums[i].first][nums[i].second] == i;`

#### Code

```c++
// m[nums[i].first][nums[i].second] == i;
class RandomizedCollection {
    unordered_map<int, vector<int>> m;
    vector<pair<int, int>> nums;
public:
    RandomizedCollection() {
        
    }
    
    bool insert(int val) {
        int ret = true;
        if (m.find(val) != m.end()) ret = false;
        m[val].push_back(nums.size());
        nums.push_back({val, m[val].size()-1});
        return ret;
    }
    // before remove, swap element with last element of nums
    bool remove(int val) {
        if (m.find(val) == m.end()) return false;
        auto last = nums.back();
        m[last.first][last.second] = m[val].back();
        nums[m[val].back()] = last;
        m[val].pop_back();
        if (m[val].empty()) m.erase(val);
        nums.pop_back();
        return true;
    }
    
    int getRandom() {
        return nums[rand() % nums.size()].first;
    }
};

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection* obj = new RandomizedCollection();
 * bool param_1 = obj->insert(val);
 * bool param_2 = obj->remove(val);
 * int param_3 = obj->getRandom();
 */
```



